"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.info = info;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("../util");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// internal helper to just split the logic - take all inputs, do the calculations and combine
function createDerivedV1(api, _ref) {
  let [bestNumber, {
    currentIndex,
    validatorCount
  }, [_lastLengthChange, sessionLength, lastEraLengthChange, sessionsPerEra]] = _ref;
  const lastLengthChange = (_lastLengthChange === null || _lastLengthChange === void 0 ? void 0 : _lastLengthChange.unwrapOr(null)) || (0, _types.createType)(api.registry, 'BlockNumber');
  const sessionProgress = bestNumber.sub(lastLengthChange).add(sessionLength).mod(sessionLength);
  const currentEra = currentIndex.sub(lastEraLengthChange).mod(sessionsPerEra);
  const eraProgress = currentEra.mul(sessionLength).add(sessionProgress);
  return {
    currentEra: (0, _types.createType)(api.registry, 'EraIndex', currentEra),
    currentIndex,
    eraLength: (0, _types.createType)(api.registry, 'BlockNumber', sessionLength.mul(sessionsPerEra)),
    eraProgress: (0, _types.createType)(api.registry, 'BlockNumber', eraProgress),
    isEpoch: false,
    sessionLength,
    sessionsPerEra,
    sessionProgress: (0, _types.createType)(api.registry, 'BlockNumber', sessionProgress),
    validatorCount
  };
}

function createDerivedLatest(api, _ref2) {
  let [[hasBabe, epochDuration, sessionsPerEra], {
    currentIndex,
    currentEra,
    validatorCount
  }, [currentSlot, epochIndex, epochOrGenesisStartSlot, currentEraStartSessionIndex]] = _ref2;
  const epochStartSlot = epochIndex.mul(epochDuration).add(epochOrGenesisStartSlot);
  const sessionProgress = currentSlot.sub(epochStartSlot);
  const eraProgress = currentIndex.sub(currentEraStartSessionIndex).mul(epochDuration).add(sessionProgress);
  return {
    currentEra,
    currentIndex,
    eraLength: (0, _types.createType)(api.registry, 'BlockNumber', sessionsPerEra.mul(epochDuration)),
    eraProgress: (0, _types.createType)(api.registry, 'BlockNumber', eraProgress),
    isEpoch: hasBabe,
    sessionLength: epochDuration,
    sessionsPerEra,
    sessionProgress: (0, _types.createType)(api.registry, 'BlockNumber', sessionProgress),
    validatorCount
  };
}

function infoV1(api) {
  return (0, _rxjs.combineLatest)([api.derive.chain.bestNumber(), api.derive.session.indexes(), api.queryMulti([api.query.session.lastLengthChange, api.query.session.sessionLength, api.query.staking.lastEraLengthChange, api.query.staking.sessionsPerEra])]).pipe((0, _operators.map)(result => createDerivedV1(api, result)));
}

function infoLatestAura(api) {
  return api.derive.session.indexes().pipe((0, _operators.map)(indexes => {
    var _api$consts$staking;

    return createDerivedLatest(api, [[false, (0, _types.createType)(api.registry, 'u64', 1), ((_api$consts$staking = api.consts.staking) === null || _api$consts$staking === void 0 ? void 0 : _api$consts$staking.sessionsPerEra) || (0, _types.createType)(api.registry, 'SessionIndex', 1)], indexes, [(0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'u64', 1), (0, _types.createType)(api.registry, 'SessionIndex', 1)]]);
  }));
}

function infoLatestBabe(api) {
  return (0, _rxjs.combineLatest)([api.derive.session.indexes(), api.queryMulti([api.query.babe.currentSlot, api.query.babe.epochIndex, api.query.babe.genesisSlot, api.query.staking.currentEraStartSessionIndex])]).pipe((0, _operators.map)((_ref3) => {
    let [indexes, slots] = _ref3;
    return createDerivedLatest(api, [[true, api.consts.babe.epochDuration, api.consts.staking.sessionsPerEra], indexes, slots]);
  }));
}
/**
 * @description Retrieves all the session and era info and calculates specific values on it as the length of the session and eras
 */


function info(api) {
  const query = api.consts.timestamp || api.consts.babe || api.consts.aura ? api.consts.babe ? infoLatestBabe // 2.x with Babe
  : infoLatestAura // 2.x with Aura (not all info there)
  : infoV1;
  return (0, _util.memo)(() => query(api));
}