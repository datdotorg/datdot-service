"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;

var _bn = _interopRequireDefault(require("bn.js"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _util2 = require("../util");

// Copyright 2017-2019 @polkadot/api-derive authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
function calcBalances(api, _ref) {
  let [accountId, bestNumber, [freeBalance, reservedBalance, locks, vesting], accountNonce] = _ref;
  let lockedBalance = (0, _types.createType)(api.registry, 'Balance');
  let lockedBreakdown = [];

  if (Array.isArray(locks)) {
    // only get the locks that are valid until passed the current block
    lockedBreakdown = locks.filter((_ref2) => {
      let {
        until
      } = _ref2;
      return bestNumber && until.gt(bestNumber);
    }); // get the maximum of the locks according to https://github.com/paritytech/substrate/blob/master/srml/balances/src/lib.rs#L699

    if (lockedBreakdown.length) {
      lockedBalance = (0, _types.createType)(api.registry, 'Balance', (0, _util.bnMax)(...lockedBreakdown.map((_ref3) => {
        let {
          amount
        } = _ref3;
        return amount;
      })));
    }
  } // Calculate the vesting balances,
  //  - offset = balance locked at genesis,
  //  - perBlock is the unlock amount


  const {
    offset: vestingTotal,
    perBlock
  } = vesting.unwrapOr((0, _types.createType)(api.registry, 'VestingSchedule'));
  const vestedBalance = (0, _types.createType)(api.registry, 'Balance', perBlock.mul(bestNumber));
  const isVesting = vestedBalance.lt(vestingTotal); // The available balance & vested has an interplay here
  // "
  // vesting is a guarantee that the account's balance will never go below a certain amount. so it functions in the opposite way, a bit like a lock that is monotonically decreasing rather than a liquid amount that is monotonically increasing.
  // locks function as the same guarantee - that a balance will not be lower than a particular amount.
  // because of this you can see that if there is a "vesting lock" that guarantees the balance cannot go below 200, and a "staking lock" that guarantees the balance cannot drop below 300, then we just have two guarantees of which the first is irrelevant.
  // i.e. (balance >= 200 && balance >= 300) == (balance >= 300)
  // ""

  const floating = freeBalance.sub(lockedBalance);
  const extraReceived = isVesting ? freeBalance.sub(vestingTotal) : new _bn.default(0);
  const availableBalance = (0, _types.createType)(api.registry, 'Balance', (0, _util.bnMax)(new _bn.default(0), isVesting && floating.gt(vestedBalance) ? vestedBalance.add(extraReceived) : floating));
  return {
    accountId,
    accountNonce,
    availableBalance,
    freeBalance,
    isVesting,
    lockedBalance,
    lockedBreakdown,
    reservedBalance,
    vestedBalance,
    vestingTotal,
    votingBalance: (0, _types.createType)(api.registry, 'Balance', freeBalance.add(reservedBalance))
  };
}

function queryBalances(api, accountId) {
  return api.queryMulti([[api.query.balances.freeBalance, accountId], [api.query.balances.reservedBalance, accountId], [api.query.balances.locks, accountId], [api.query.balances.vesting, accountId]]);
}
/**
 * @name all
 * @param {( AccountIndex | AccountId | Address | string )} address - An accounts Id in different formats.
 * @returns An object containing the results of various balance queries
 * @example
 * <BR>
 *
 * ```javascript
 * const ALICE = 'F7Hs';
 *
 * api.derive.balances.all(ALICE, ({ accountId, lockedBalance }) => {
 *   console.log(`The account ${accountId} has a locked balance ${lockedBalance} units.`);
 * });
 * ```
 */


function all(api) {
  return (0, _util2.memo)(address => api.derive.accounts.info(address).pipe((0, _operators.switchMap)((_ref4) => {
    let {
      accountId
    } = _ref4;
    return accountId ? (0, _rxjs.combineLatest)([(0, _rxjs.of)(accountId), api.derive.chain.bestNumber(), queryBalances(api, accountId), // FIXME This is having issues with Kusama, only use accountNonce atm
    // api.rpc.account && api.rpc.account.nextIndex
    //   ? api.rpc.account.nextIndex(accountId)
    //   // otherwise we end up with this: type 'Codec | Index' is not assignable to type 'Index'.
    //   : api.query.system.accountNonce<Index>(accountId)
    api.query.system.accountNonce(accountId)]) : (0, _rxjs.of)([(0, _types.createType)(api.registry, 'AccountId'), (0, _types.createType)(api.registry, 'BlockNumber'), [(0, _types.createType)(api.registry, 'Balance'), (0, _types.createType)(api.registry, 'Balance'), (0, _types.createType)(api.registry, 'Vec<BalanceLock>'), (0, _types.createType)(api.registry, 'Option<VestingSchedule>', null)], (0, _types.createType)(api.registry, 'Index')]);
  }), (0, _operators.map)(result => calcBalances(api, result))));
}