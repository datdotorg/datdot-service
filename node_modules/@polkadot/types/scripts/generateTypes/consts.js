"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateConsts;

var definitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var _fs = _interopRequireDefault(require("fs"));

var _static = _interopRequireDefault(require("@polkadot/metadata/Metadata/static"));

var _util = require("@polkadot/util");

var _ = require("../..");

var _util2 = require("../util");

// Copyright 2017-2019 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// Generate types for one module
function generateModule(modul, imports) {
  if (!modul.constants.length) {
    return [];
  }

  (0, _util2.setImports)(definitions, imports, ['Codec']);
  return [(0, _util2.indent)(4)("".concat((0, _util.stringCamelCase)(modul.name.toString()), ": {"))].concat((0, _util2.indent)(6)('[index: string]: Codec;')).concat(modul.constants.map(constant => {
    (0, _util2.setImports)(definitions, imports, [constant.type.toString()]);
    return (0, _util2.indent)(6)("".concat((0, _util.stringCamelCase)(constant.name.toString()), ": ").concat(constant.type, " & ConstantCodec;"));
  })).concat([(0, _util2.indent)(4)('};')]);
} // Generate `packages/api/src/consts.types.ts` for a particular
// metadata


function generateForMeta(meta) {
  console.log('Writing packages/api/src/consts.types.ts');
  const imports = (0, _util2.createImports)({
    '@polkadot/types/interfaces': definitions
  }); // Will hold all needed imports

  const body = meta.asLatest.modules.reduce((acc, modul) => {
    const storageEntries = generateModule(modul, imports);
    return acc.concat(storageEntries);
  }, []);
  const header = (0, _util2.createImportCode)(_util2.HEADER, [{
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@polkadot/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  })), {
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }]);
  const interfaceStart = ["declare module '@polkadot/metadata/Decorated/types' {", (0, _util2.indent)(2)('export interface Constants {\n')].join('\n');
  const interfaceEnd = "\n".concat((0, _util2.indent)(2)('}'), "\n}");

  _fs.default.writeFileSync('packages/api/src/consts.types.ts', header.concat(interfaceStart).concat(body.join('\n')).concat(interfaceEnd).concat(_util2.FOOTER), {
    flag: 'w'
  });
} // Call `generateForMeta()` with current static metadata


function generateConsts() {
  const registry = new _.TypeRegistry();
  return generateForMeta(new _.Metadata(registry, _static.default));
}