"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateRpcTypes;

var _fs = _interopRequireDefault(require("fs"));

var _src = _interopRequireDefault(require("../../../../type-jsonrpc/src"));

var definitions = _interopRequireWildcard(require("../../interfaces/definitions"));

var _create = require("../../codec/create");

var _util = require("../util");

// Copyright 2017-2020 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
// Generate `packages/rpc-core/jsonrpc.types.ts`
function generateRpcTypes() {
  console.log('Writing packages/rpc-core/jsonrpc.types.ts');
  const registry = new _create.TypeRegistry();
  const imports = (0, _util.createImports)({
    '@polkadot/types/interfaces': definitions
  });
  const body = Object.keys(_src.default).sort().reduce((allSections, section) => {
    const allMethods = Object.keys(_src.default[section].methods).sort().map(key => {
      const method = _src.default[section].methods[key];
      (0, _util.setImports)(definitions, imports, [method.type]); // FIXME These 2 are too hard to type, I give up

      if (section === 'state') {
        if (method.method === 'getStorage') {
          (0, _util.setImports)(definitions, imports, ['Codec']);
          return '    getStorage<T = Codec>(key: any, block?: Hash | Uint8Array | string): Observable<T>;';
        } else if (method.method === 'subscribeStorage') {
          return '    subscribeStorage<T = Codec[]>(keys: any[]): Observable<T>;';
        }
      }

      const args = method.params.map(param => {
        const similarTypes = (0, _util.getSimilarTypes)(definitions, registry, param.type, imports);
        (0, _util.setImports)(definitions, imports, [param.type, ...similarTypes]);
        return "".concat(param.name).concat(param.isOptional ? '?' : '', ": ").concat(similarTypes.join(' | '));
      });
      return "    ".concat(method.method, "(").concat(args.join(', '), "): Observable<").concat(method.type, ">;");
    });
    return allSections.concat(["  ".concat(section, ": {"), ...allMethods, '  };'].join('\n'));
  }, []).join('\n');
  const header = (0, _util.createImportCode)(_util.HEADER, [{
    file: 'rxjs',
    types: ['Observable']
  }, {
    file: '@polkadot/types/codec',
    types: Object.keys(imports.codecTypes).filter(name => name !== 'Tuple')
  }, {
    file: '@polkadot/types',
    types: Object.keys(imports.primitiveTypes)
  }, ...Object.keys(imports.localTypes).map(moduleName => ({
    file: "@polkadot/types/interfaces/".concat(moduleName),
    types: Object.keys(imports.localTypes[moduleName])
  })), {
    file: '@polkadot/types/types',
    types: Object.keys(imports.typesTypes)
  }]);
  const interfaceStart = 'export interface RpcInterface {\n';
  const interfaceEnd = '\n}';

  _fs.default.writeFileSync('packages/rpc-core/src/jsonrpc.types.ts', header.concat(interfaceStart).concat(body).concat(interfaceEnd).concat(_util.FOOTER), {
    flag: 'w'
  });
}