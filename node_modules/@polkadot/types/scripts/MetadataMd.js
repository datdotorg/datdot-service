"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _fs = _interopRequireDefault(require("fs"));

var _Decorated = _interopRequireDefault(require("@polkadot/metadata/Decorated"));

var _static = _interopRequireDefault(require("@polkadot/metadata/Metadata/static"));

var _util = require("@polkadot/util");

var _src = _interopRequireDefault(require("../../../type-jsonrpc/src"));

var _StorageKey = require("../primitive/StorageKey");

var _Call = _interopRequireDefault(require("../primitive/Generic/Call"));

var _codec = require("../codec");

// Copyright 2017-2020 @polkadot/types authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const ANCHOR_TOP = '';
const LINK_BACK_TO_TOP = '';
const STATIC_TEXT = '\n\n(NOTE: These were generated from a static/snapshot view of a recent Substrate master node. Some items may not be available in older nodes, or in any customized implementations.)';
const DESC_CONSTANTS = "\n\nThe following sections contain the module constants, also known as parameter types. These can only be changed as part of a runtime upgrade. On the api, these are exposed via `api.consts.<module>.<method>`. ".concat(STATIC_TEXT, "\n");
const DESC_EXTRINSICS = "\n\nThe following sections contain Extrinsics methods are part of the default Substrate runtime. On the api, these are exposed via `api.tx.<module>.<method>`. ".concat(STATIC_TEXT, "\n");
const DESC_EVENTS = "\n\nEvents are emitted for certain operations on the runtime. The following sections describe the events that are part of the default Substrate runtime. ".concat(STATIC_TEXT, "\n");
const DESC_RPC = '\n\nThe following sections contain RPC methods that are Remote Calls available by default and allow you to interact with the actual node, query, and submit.\n';
const DESC_STORAGE = "\n\nThe following sections contain Storage methods are part of the default Substrate runtime. On the api, these are exposed via `api.query.<module>.<method>`. ".concat(STATIC_TEXT, "\n");

function sectionLink(sectionName) {
  return "- **[".concat((0, _util.stringCamelCase)(sectionName), "](#").concat((0, _util.stringCamelCase)(sectionName), ")**\n\n");
}

function generateSectionHeader(md, sectionName) {
  return "".concat(md, "\n___\n").concat(LINK_BACK_TO_TOP, "\n\n## ").concat(sectionName, "\n");
}

function addRpc() {
  const renderHeading = "## ".concat(ANCHOR_TOP, "JSON-RPC").concat(DESC_RPC, "\n");
  const orderedSections = Object.keys(_src.default).sort();
  const renderAnchors = Object.keys(_src.default).sort().map(sectionName => sectionLink(sectionName)).join('');
  return orderedSections.reduce((md, sectionName) => {
    const section = _src.default[sectionName];
    const renderSection = generateSectionHeader(md, sectionName) + "\n_".concat(section.description, "_\n");
    const orderedMethods = Object.keys(section.methods).sort();
    return orderedMethods.reduce((md, methodName) => {
      const method = section.methods[methodName];
      const args = method.params.map(({
        name,
        isOptional,
        type
      }) => {
        return name + (isOptional ? '?' : '') + ': `' + type + '`';
      }).join(', ');
      const type = '`' + method.type + '`';
      return "".concat(md, "\n### ").concat(methodName, "(").concat(args, "): ").concat(type, "\n- **jsonrpc**: ").concat(sectionName, "_").concat(methodName, "\n- **interface**: api.rpc.").concat(sectionName, ".").concat(methodName) + (method.description ? "\n- **summary**: ".concat(method.description, "\n") : '\n\n');
    }, renderSection);
  }, renderHeading + renderAnchors);
}
/**
 * Sort object by their `.name`
 */


function sortByName(a, b) {
  // ignore upper and lowercase
  const nameA = a.name.toString().toUpperCase();
  const nameB = b.name.toString().toUpperCase();
  return nameA.localeCompare(nameB);
}

function addConstants(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Constants").concat(DESC_CONSTANTS);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, moduleMetadata) => {
    if (moduleMetadata.constants.isEmpty) {
      return md;
    }

    const sectionName = (0, _util.stringLowerFirst)(moduleMetadata.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedConstants = moduleMetadata.constants.sort(sortByName);
    return orderedConstants.reduce((md, func) => {
      const methodName = (0, _util.stringCamelCase)(func.name.toString());
      const doc = func.documentation.reduce((md, doc) => "".concat(md.length ? "".concat(md, " ") : '').concat(doc.trim()), '');
      return "".concat(md, "\n### ").concat(methodName, ": ") + '`' + func.type + '`' + "\n- **interface**: api.consts.".concat(sectionName, ".").concat(methodName) + (doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addEvents(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Events").concat(DESC_EVENTS);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, meta) => {
    if (meta.events.isNone || !meta.events.unwrap().length) {
      return md;
    }

    const events = meta.events.unwrap();
    const sectionName = (0, _util.stringCamelCase)(meta.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = events.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const methodName = func.name.toString();
      const args = func.args.map(type => '`' + type + '`').join(', ');
      const doc = func.documentation.reduce((md, doc) => "".concat(md.length ? "".concat(md, " ") : '').concat(doc.trim()), '');
      return "".concat(md, "\n### ").concat(methodName, "(").concat(args, ")") + "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addExtrinsics(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Extrinsics").concat(DESC_EXTRINSICS);
  const orderedSections = metadata.modules.map(i => i).sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, meta) => {
    if (meta.calls.isNone || !meta.calls.unwrap().length) {
      return md;
    }

    const calls = meta.calls.unwrap();
    const sectionName = (0, _util.stringCamelCase)(meta.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = calls.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const methodName = (0, _util.stringCamelCase)(func.name.toString());

      const args = _Call.default.filterOrigin(func).map(({
        name,
        type
      }) => "".concat(name, ": ") + '`' + type + '`').join(', ');

      const doc = func.documentation.reduce((md, doc) => "".concat(md.length ? "".concat(md, " ") : '').concat(doc.trim()), '');
      return "".concat(md, "\n### ").concat(methodName, "(").concat(args, ")") + "\n- **interface**: api.tx.".concat(sectionName, ".").concat(methodName) + "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sections;
}

function addStorage(metadata) {
  const renderHeading = "## ".concat(ANCHOR_TOP, "Storage").concat(DESC_STORAGE);
  const orderedSections = metadata.modules.sort(sortByName);
  let renderAnchors = '';
  const sections = orderedSections.reduce((md, moduleMetadata) => {
    if (moduleMetadata.storage.isNone) {
      return md;
    }

    const sectionName = (0, _util.stringLowerFirst)(moduleMetadata.name.toString());
    renderAnchors += sectionLink(sectionName);
    const renderSection = generateSectionHeader(md, sectionName);
    const orderedMethods = moduleMetadata.storage.unwrap().items.sort(sortByName);
    return orderedMethods.reduce((md, func) => {
      const arg = func.type.isMap ? '`' + func.type.asMap.key.toString() + '`' : func.type.isDoubleMap ? '`' + func.type.asDoubleMap.key1.toString() + ', ' + func.type.asDoubleMap.key2.toString() + '`' : '';
      const doc = func.documentation.reduce((md, doc) => "".concat(md.length ? "".concat(md, " ") : '').concat(doc.trim()), '');
      let result = (0, _StorageKey.unwrapStorageType)(func.type);

      if (func.modifier.isOptional) {
        result = "Option<".concat(result, ">");
      }

      const methodName = (0, _util.stringLowerFirst)(func.name.toString());
      return "".concat(md, "\n### ").concat(methodName, "(").concat(arg, "): ") + '`' + result + '`' + "\n- **interface**: api.query.".concat(sectionName, ".").concat(methodName) + "".concat(doc ? "\n- **summary**: ".concat(doc, "\n") : '\n');
    }, renderSection);
  }, '');
  return renderHeading + renderAnchors + sectionLink('substrate') + sections;
}

function writeFile(name, ...chunks) {
  const options = {
    flags: 'w',
    encoding: 'utf8'
  };

  const writeStream = _fs.default.createWriteStream(name, options);

  writeStream.on('finish', () => {
    console.log("Completed writing ".concat(name));
  });
  chunks.forEach(chunk => {
    writeStream.write(chunk);
  });
  writeStream.end();
}

function writeToRpcMd() {
  writeFile('docs/substrate/rpc.md', addRpc());
}

function writeToConstantsMd(metadata) {
  writeFile('docs/substrate/constants.md', addConstants(metadata));
}

function writeToStorageMd(metadata) {
  const options = {
    flags: 'r',
    encoding: 'utf8'
  };

  const data = _fs.default.readFileSync('docs/substrate/storage-known.md', options);

  writeFile('docs/substrate/storage.md', addStorage(metadata), data);
}

function writeToExtrinsicsMd(metadata) {
  writeFile('docs/substrate/extrinsics.md', addExtrinsics(metadata));
}

function writeToEventsMd(metadata) {
  writeFile('docs/substrate/events.md', addEvents(metadata));
}

const registry = new _codec.TypeRegistry();
const decorated = new _Decorated.default(registry, _static.default);
const latest = decorated.metadata.asLatest;
writeToRpcMd();
writeToConstantsMd(latest);
writeToStorageMd(latest);
writeToExtrinsicsMd(latest);
writeToEventsMd(latest);