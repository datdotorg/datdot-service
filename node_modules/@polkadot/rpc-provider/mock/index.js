"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bn = _interopRequireDefault(require("bn.js"));

var _eventemitter = _interopRequireDefault(require("eventemitter3"));

var _Decorated = _interopRequireDefault(require("@polkadot/metadata/Decorated"));

var _static = _interopRequireDefault(require("@polkadot/metadata/Metadata/static"));

var _jsonrpc = _interopRequireDefault(require("@polkadot/jsonrpc"));

var _testing = _interopRequireDefault(require("@polkadot/keyring/testing"));

var _SignedBlock004Immortal = _interopRequireDefault(require("@polkadot/types/json/SignedBlock.004.immortal.json"));

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

var _utilCrypto = require("@polkadot/util-crypto");

/* eslint-disable @typescript-eslint/camelcase */
// Copyright 2017-2019 @polkadot/rpc-provider authors & contributors
// This software may be modified and distributed under the terms
// of the Apache-2.0 license. See the LICENSE file for details.
const INTERVAL = 1000;
const SUBSCRIPTIONS = Array.prototype.concat.apply([], Object.values(_jsonrpc.default).map(area => Object.values(area.methods).filter(method => method.isSubscription).map((_ref) => {
  let {
    method,
    section
  } = _ref;
  return "".concat(section, "_").concat(method);
}).concat('chain_subscribeNewHead')));
const keyring = (0, _testing.default)({
  type: 'ed25519'
});
const l = (0, _util.logger)('api-mock');
/**
 * A mock provider mainly used for testing.
 * @return {ProviderInterface} The mock provider
 */

class Mock {
  constructor(registry) {
    this.db = {};
    this.emitter = new _eventemitter.default();
    this.isUpdating = true;
    this.registry = void 0;
    this.requests = {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      chain_getBlock: hash => (0, _types.createType)(this.registry, 'SignedBlock', _SignedBlock004Immortal.default.result).toJSON(),
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      chain_getBlockHash: blockNumber => '0x1234',
      state_getRuntimeVersion: () => (0, _types.createType)(this.registry, 'RuntimeVersion').toHex(),
      state_getStorage: (storage, params) => {
        return (0, _util.u8aToHex)(storage[params[0]]);
      },
      system_chain: () => 'mockChain',
      state_getMetadata: () => _static.default,
      system_name: () => 'mockClient',
      system_properties: () => ({
        ss58Format: 42
      }),
      system_version: () => '9.8.7'
    };
    this.subscriptions = SUBSCRIPTIONS.reduce((subs, name) => {
      subs[name] = {
        callbacks: {},
        lastValue: null
      };
      return subs;
    }, {});
    this.subscriptionId = 0;
    this.subscriptionMap = {};
    this.registry = registry;
    this.init();
  }

  get hasSubscriptions() {
    return true;
  }

  clone() {
    throw new Error('Unimplemented');
  }

  disconnect() {// noop
  }

  isConnected() {
    return true;
  }

  on(type, sub) {
    this.emitter.on(type, sub);
  } // eslint-disable-next-line @typescript-eslint/require-await


  async send(method, params) {
    if (!this.requests[method]) {
      throw new Error("provider.send: Invalid method '".concat(method, "'"));
    }

    return this.requests[method](this.db, params);
  } // eslint-disable-next-line @typescript-eslint/require-await


  async subscribe(type, method) {
    for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      params[_key - 2] = arguments[_key];
    }

    l.debug(() => ['subscribe', method, params]);

    if (this.subscriptions[method]) {
      const callback = params.pop();
      const id = ++this.subscriptionId;
      this.subscriptions[method].callbacks[id] = callback;
      this.subscriptionMap[id] = method;

      if (this.subscriptions[method].lastValue !== null) {
        callback(null, this.subscriptions[method].lastValue);
      }

      return id;
    }

    throw new Error("provider.subscribe: Invalid method '".concat(method, "'"));
  } // eslint-disable-next-line @typescript-eslint/require-await


  async unsubscribe(type, method, id) {
    const sub = this.subscriptionMap[id];
    l.debug(() => ['unsubscribe', id, sub]);

    if (!sub) {
      throw new Error("Unable to find subscription for ".concat(id));
    }

    delete this.subscriptionMap[id];
    delete this.subscriptions[sub].callbacks[id];
    return true;
  }

  init() {
    const emitEvents = ['connected', 'disconnected'];
    let emitIndex = 0;
    let newHead = this.makeBlockHeader(new _bn.default(-1));
    let counter = -1;
    const metadata = new _Decorated.default(this.registry, _static.default); // Do something every 1 seconds

    setInterval(() => {
      if (!this.isUpdating) {
        return;
      } // create a new header (next block)


      newHead = this.makeBlockHeader(newHead.number.toBn()); // increment the balances and nonce for each account

      keyring.getPairs().forEach((_ref2, index) => {
        let {
          publicKey
        } = _ref2;
        this.setStateBn(metadata.query.balances.freeBalance(publicKey), newHead.number.toBn().muln(3).iaddn(index));
        this.setStateBn(metadata.query.system.accountNonce(publicKey), newHead.number.toBn().addn(index));
      }); // set the timestamp for the current block

      this.setStateBn(metadata.query.timestamp.now(), Math.floor(Date.now() / 1000));
      this.updateSubs('chain_subscribeNewHead', newHead); // We emit connected/disconnected at intervals

      if (++counter % 2 === 1) {
        if (++emitIndex === emitEvents.length) {
          emitIndex = 0;
        }

        this.emitter.emit(emitEvents[emitIndex]);
      }
    }, INTERVAL);
  }

  makeBlockHeader(prevNumber) {
    const blockNumber = prevNumber.addn(1);
    return (0, _types.createType)(this.registry, 'Header', {
      digest: {
        logs: []
      },
      extrinsicsRoot: (0, _utilCrypto.randomAsU8a)(),
      number: blockNumber,
      parentHash: blockNumber.isZero() ? new Uint8Array(32) : (0, _util.bnToU8a)(prevNumber, 256, false),
      stateRoot: (0, _util.bnToU8a)(blockNumber, 256, false)
    });
  }

  setStateBn(key, value) {
    this.db[(0, _util.u8aToHex)(key)] = (0, _util.bnToU8a)(value, 64, true);
  }

  updateSubs(method, value) {
    this.subscriptions[method].lastValue = value;
    Object.values(this.subscriptions[method].callbacks).forEach(cb => {
      try {
        cb(null, value.toJSON());
      } catch (error) {
        console.error("Error on '".concat(method, "' subscription"), error);
      }
    });
  }

}

exports.default = Mock;