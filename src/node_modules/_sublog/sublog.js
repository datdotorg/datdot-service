const { performance } = require('perf_hooks')

const codec = require('./codec')
sublog.codec = codec

module.exports = sublog

function sublog (name, emit = () => {}) {
  const loggers = {}
  const loglog = makelog([name])
  return loglog
  function makelog (names) {
    const path = names.map(name => name.toLowerCase()).join(':')
    if (loggers[path]) {
      loglog({ type: 'warn', data: `requesting logger "${path}" more than once` })
      return loggers[path].log
    }
    function log (...args) {
      try {
        if (args.length === 0) throw new Error('missing logging content')
        if (args.length > 2) throw new Error('too many arguments to log')
        const [to, content] = args.length === 1 ? ['*', args[0]] : args
        if (!to || typeof to !== 'string') throw new Error('invalid recipient')
        const { address } = loggers[path]
        if (!Number.isInteger(address[to])) address[to] = 0
        const msg = content.type ? content : { data : content }
        const { refs = [], type = 'info', data, ...rest } = msg
        if (rest.length) throw new Error('invalid additional message fields')
        const mid = address[to]++
        const head = [path, to, mid]
        const timestamp = performance.now()
        const stack = prepareStack(new Error().stack) // @TODO: stackframe
        const meta = { timestamp, stack }
        const message = { head, refs, type, meta, data }
        const json = codec.encode(message)
        emit(json)
      } catch (error) {
        loglog(...args)
        throw error
      }
    }
    log.path = path
    log.sub = subname => {
      if (!subname || typeof subname !== 'string') throw new Error('invalid logger name')
      return makelog(names.concat(subname))
    }
    Object.freeze(log)
    loggers[path] = { log, from: path, address: { '*': 0 } }
    return log
  }
}


function prepareStack (stack) {
  const excludes = [
    'task_queues.js',
    'timers.js',
    'websocket.js',
    'receiver.js',
    'destroy.js',
  ]
  const len = excludes.length
  const callsites = stack.split('\n').slice(2).map(x => x.split('/').pop().slice(0, -1))
  const sites = callsites.map(x => x.includes('(') ? '' : x).reverse()
  var last
  function onlylast (arr, x) {
    const name = x.split(':')[0]
    const [_name,_i] = last || []
    if (name === _name) arr[_i] = x
    else last = [name, arr.push(x) - 1]
    return arr
  }
  return sites.filter(excludefiles).reduce(onlylast, [])
  function excludefiles (x) {
    if (!x) return
    for (var i = 0; i < len; i++) if (x.includes(excludes[i])) return
    return true
  }
}
