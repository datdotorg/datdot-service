const proof_codec = require('./proof.js')
const b4a = require('b4a')

module.exports = { decode, encode }

// @NOTE: X === encode(decode(X))

function decode (message, log) {
  try {
    const data = message.args[0]
    var { proof_of_contact, reports } = data
    var { proof } = proof_of_contact
    log({ type: 'codec', data: { text: `DECODING MESSAGE`, data: message.args[0] }  })
    if (proof) {
      console.log('checksing proof', proof)
      data.proof_of_contact.proof = Buffer.isBuffer(proof) ? proof : b4a.from(proof, 'hex')
    }
    
    for (var i = 0, len = reports.length; i < len; i++) {
      const p = reports[i].p
      data.reports[i].p = proof_codec.to_buffer(p)
      log({ type: 'codec', data: { text: `storage report`, p: data.reports[i].p  } })
    }
    const err = invalidate(data)
    if (err) throw err
    log({ type: 'codec', data: { text: `Returning decoded storage-report: ${Object.keys(message)}` } })
    return message
  } catch (error) {
    throw new Error('invalid data', { cause: error })
  }
}

function encode (data) {
  const err = invalidate(message)
  if (err) throw err
  const chunk = Buffer.from({}, 'hex')
  return chunk
}

function invalidate (data) {
  try {
    const { storageChallengeID, proof_of_contact, reports } = data
    const { status, proof } = proof_of_contact
    if (!storageChallengeID) throw new Error('storageChallengeID missing', data)
    if (!proof_of_contact) throw new Error('proof_of_contact missing', data)
    if (!status) throw new Error('proof_of_contact missing', proof_of_contact)
    if (!reports) throw new Error('reports missing', data)
    for (const report of reports) {
      const { contractID, p } = report      
      if (!contractID) throw new Error('contractID missing', report)
      if (!p) throw new Error('p missing', report)
    }
    return
  } catch (error) {
    return error
  }

}