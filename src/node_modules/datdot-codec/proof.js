const varint = require('varint')
const b4a = require('b4a')

module.exports = { decode, encode, to_string, to_buffer }

// @NOTE: X === encode(decode(X))

function decode (data) {
  try {
    const message = JSON.parse(data)
    var { type, index, encoded_data, encoded_data_signature, p, contractID } = message
    encoded_data = Buffer.isBuffer(encoded_data) ? encoded_data : b4a.from(encoded_data, 'hex')
    encoded_data_signature = Buffer.isBuffer(encoded_data_signature) ? encoded_data_signature : b4a.from(encoded_data_signature, 'hex')
    
    const parsed_message = { 
      type,
      index, 
      encoded_data,
      encoded_data_signature,
      p,
      contractID
    }
    const invalid = invalidate(parsed_message)
    if (invalid) throw invalid
    return parsed_message
  } catch (error) {
    throw error
  }
}

function encode (message) {
  const err = invalidate(message)
  if (err) throw err
  const stringified = JSON.stringify(message)
  const buff = b4a.from(stringified)
  return buff
}

function invalidate (message) {
  try {
    const { type, index, encoded_data, encoded_data_signature, p  } = message
    if (type !== 'proof') throw new Error('invalid message.type', message)
    if (index === undefined) throw new Error('missing mesage.index', message)
    if (!encoded_data) throw new Error('missing mesage.encoded_data', message)
    if (!encoded_data_signature) throw new Error('missing mesage.encoded_data_signature', message)
    if (!p) throw new Error('missing mesage.p', message)
    return
  } catch (error) {
    return error
  }
}

function to_string (p) {
  // turn signature and hashes into a string and stringify proof object
  if (typeof p !== 'object') throw new Error('invalid proof type')
  if (p.upgrade) {
    p.upgrade.signature = p.upgrade.signature.toString('hex')
    p.upgrade.nodes.forEach(node => { node.hash = node.hash.toString('hex') })
    p.upgrade.additionalNodes.forEach(node => { node.hash = node.hash.toString('hex') })
  }
  if (p.block) {
    p.block.nodes.forEach(node => { node.hash = node.hash.toString('hex') })
    p.block.value = p.block.value.toString() // binary encoding
  }
  return JSON.stringify(p)
}

function to_buffer (p) {
  if (typeof p !== 'string') throw new Error('invalid proof type')
  p = JSON.parse(p)
  if (p.block) {
    p.block.value = b4a.from(p.block.value) // binary encoding
    p.block.nodes.forEach(node => { node.hash = b4a.from(node.hash, 'hex') })
  }
  if (p.upgrade) {
    p.upgrade.signature = b4a.from(p.upgrade.signature, 'hex')
    p.upgrade.nodes.forEach(node => { node.hash = b4a.from(node.hash, 'hex') })
  }
  return p
}