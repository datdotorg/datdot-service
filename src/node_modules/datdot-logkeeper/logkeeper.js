const WebSocket = require('ws')
const { performance } = require('perf_hooks')
const debug = require('debug')

const docs = {
  'all:live': `receive all log message and subscribe to future messages`
}

function codec (from, into, counter = 0) {
  function decode (json) { return JSON.parse(json) }
  function encode (type, [data, stack], refs) {
    const head = [from, into, counter++, performance.now()]
    const message = { head, refs, type, meta: { stack }, data }
    return JSON.stringify(message)
  }
  return { encode, decode }
}

var instance = void 0

module.exports = logkeeper

async function logkeeper (name, PORT) {
  PORT = Number(PORT)
  if (instance) throw new Error('logkeeper already initialized')
  if (typeof name !== 'string') throw new Error('invalid logger name')
  if (!Number.isInteger(PORT)) throw new Error('invalid logger port')
  return new Promise(connect)
  function connect (resolve, reject) {
    const LOG = debug(`logkeeper:${name}`)
    const connections = []
    const history = [] // TODO: should be a persistent hypercore
    const loggers = {}
    function get (path) { return loggers[path] }
    instance = loggers[name] = makelog([name])
    function makelog (names) {
      const path = names.join('/')
      if (loggers[path]) {
        // LOG(`warning: requesting logger "${path}" more than once`)
        return loggers[path]
      }
      const { encode, decode } = codec(path, '*')
      function log (...args) {
        const stack = new Error().stack
        args.push(stack)
        if (args.length > 2 || args.length === 0 ||!args[0]) {
          console.log(name, args.length, args)
          throw new Error('invalid logs')
        }
        if (!args[0].type) {
          console.log(name, args[0])
          throw new Error('invalid type')
        }
        const message = encode('log', args)

        // =========================================================
        const _message = decode(message)
        const _name = _message.head[0]
        const { type: _type, data: _data } = _message.data
        const _log = debug(`${_name}<${_type}>`)

        function excludefiles (x) { return x && !x.includes('task_queues.js') && !x.includes('timers.js') }
        const callsites = stack.includes('receiver.js') ? [] : stack.split('\n').slice(2).map(x => x.split('/').pop().slice(0, -1))
        const sites = callsites.map(x => x.includes('(') ? '' : x).filter(excludefiles).reverse()
        var last
        function onlylast (arr, x) {
          const name = x.split(':')[0]
          const [_name,_i] = last || []
          if (name === _name) arr[_i] = x
          else last = [name, arr.push(x) - 1]
          return arr
        }
        _log(sites.reduce(onlylast, []))
        _log(...[].concat(_data))
        // =========================================================


        history.push(message)
        for (var i = 0, len = connections.length; i < len; i++) {
          const client = connections[i]
          if (client) client.send(message)
        }
      }
      log.path = path
      log.sub = subname => {
        if (!subname || typeof subname !== 'string') throw new Error('invalid logger name')
        return makelog(names.concat(subname))
      }
      Object.freeze(log)
      return loggers[path] = log
    }
    const wss = new WebSocket.Server({ port: PORT }, after)
    function after () {
      LOG(`running on http://localhost:${wss.address().port}`)
    }
    resolve([instance, get])
    wss.on('connection', function connection (ws) {
      const index = connections.push(ws) - 1
      ws.on('message', function incoming (message) {
        console.log('New message')
        message = JSON.parse(message)
        const { head, type, data } = message
        const [from, into, id] = head
        if (type === 'all:live') {
          LOG('send logs to client:', from)
          for (var i = 0, len = history.length; i < len; i++) ws.send(history[i])
        } else LOG('client sent unknown message', message)
      })
      ws.on('close', function close () {
        connections[index] = undefined
        LOG(`client ${index} disconnected from logkeeper ${name}/${PORT} logkeeper`)
      })
      ws.on('error', function error (err) {
        connections[index] = undefined
        LOG(`ERROR: client ${index} disconnected from logkeeper ${name}/${PORT} logkeeper`, err)
      })
    })
  }
}
