module.exports = calculate

function get_index (multiplier, level) {
  const Z = level            // = 2
  const M = multiplier       //              = 2
  const Y = (2n ** (Z + 1n)) //         = 8
  const X = (2n ** Z) - 1n   //    = 3
  const D = X + Y * M        // 19 = 3 +  8 *  2
  const hash_index = D
  return hash_index
}
function get_level (hash_index) {
  for (var mask = 1n, Z = 0n; hash_index & mask; mask <<= 1n) Z++
  return Z
}
function get_multiplier (hash_index, level) {
  const M = hash_index >> (level + 1n) // e.g. M = 19 >> (2 + 1)
  return M
}
function is_lower (multiplier) {
  const bit = multiplier & 1n // (bit = 2n & 1n) === 0
  const bool = !bit // = !0
  return bool
}
function get_sibling (t, n) {
  const mask = n << 1n // (n * (2**1))
  // const mask = 1n << (level + 1) // === (1n << level) << 1n
  const sibling = t ^ mask
  return sibling
}
function get_parent (t, n) {
  const mask = ~(n << 1n)
  const L = t & mask
  const parent = L | n
  return parent
}
function dec2bin (dec) {
  return dec.toString(2).padStart(64, '0')
}
function calculate_one (index, version) {
  const max = version + 1n
  return { path: calculate(index, version), root: calculate(max, max)  }
}
function calculate_version (version) {
  const out = { indexes: [] }
  out.indexes.push(calculate_paths(version))
  out.root = calculate_root(version)
  return out
}
function calculate_all (versions) {
  const out = { indexes: [] }
  for (var i = 0n, max = versions + 1n; i < max; i++) {
    out.indexes.push(calculate_paths(i))
    out.root = calculate_root(i)
  }
  return out
}
function calculate_paths (version) {
  const out = []
  for (var j = 0n, max = version + 1n; j < max; j++) {
    const merkle_proof_indexes = calculate(j, version)
    out.push(merkle_proof_indexes)
    console.log(`calculate(${version},${j}) =>`, merkle_proof_indexes) 
  }
  return out
}
function calculate_root (max_index) {
  const [version, chunk_idx] = [max_index + 1n, max_index + 1n]
  const children_of_root = calculate(chunk_idx, version)
  console.log(`calculate(${version})   =>`, children_of_root)
  console.log('-----------------------------')
  return children_of_root
}
function calculate (chunk_idx, version) {
  if (typeof chunk_idx !== 'bigint') throw new Error('`chunk_idx` must be a bigint')
  if (typeof version !== 'bigint') throw new Error('`version` must be a bigint')
  if (version < 0) throw new Error('`version` must be non negative')
  if (chunk_idx < 0) throw new Error('`chunk_idx` must be non negative')
  if (chunk_idx > version) throw new Error('`chunk_idx` must not be bigger than `version`')
  const max_hash_index = (version << 1n)     // version   * (2**1)
  const chunk_hash_index = (chunk_idx << 1n) // chunk_idx * (2**1)
  const max_bigint  = 2n ** (64n - 1n) - 1n
  const max_version = 2n ** (64n - 2n) - 1n
  if (max_hash_index > max_bigint) throw new Error('max `version` supported is ' + max_version)
  const level = 0n
  const out = []

  var a = chunk_hash_index   // e.g. 6  (chunk_index = 3)
  var b = max_hash_index     // e.g. 10 (version = 5)
  var intersected = (a === b)
  var bbb = false // whether some descendant of x is greater than version

  var siblingA, siblingB, parentA, parentB

  for (var n = 1n << level; n <= version; n <<= 1n, a = parentA, b = parentB) {
    siblingA = get_sibling(a, n)
    siblingB = get_sibling(b, n)
    parentA = get_parent(a, n)
    parentB = get_parent(b, n)

    if (intersected) { // after a and b meet on their path to the root
      // if SIBLING < PARENT ==> LOWER SUBTREE
      if (siblingB < parentB) out.push(siblingB)
    } else if (parentA === parentB) { // they meet for the first time
      intersected = true
      // if no decendant > version
      if (!bbb) out.push(b)
    } else { // a and b have not met yet
      // => so `a < b`

      // if no decendant of PARENT > version   &&
      if (!bbb && (parentB > b)) { // PARENT > B ==> HIGHER BRANCH
        bbb = true
        out.push(b)
      } else if (bbb && (b > parentB)) out.push(siblingB)
      out.push(siblingA) // A: default means add `sibling(a)` + repeat with parentA
    }
  }
  return out.sort((a,b) => a > b ? 1 : -1)
}

const nodes = calculate(3n,17n)
console.log(nodes.map(n => Number(n)))

// var aa = !true
// console.log(JSON.stringify((() => {
//   const max_example = (2n ** (64n - 2n)) - 2n
//   // return calculate_one(max_example, max_example)
// //   return calculate_one(3n, 5n)
// //   return calculate_version(5n)
//   return calculate_all(15n)
// })(), (K, V) => typeof V === 'bigint' ? V.toString() : V, 0))