const ApiPromise = require('./simulate-polkadotjs')
// const { ApiPromise, WsProvider, Keyring } = require('@polkadot/api')
// const { randomAsU8a } = require('@polkadot/util-crypto') // make sure version matches api version
// const { hexToBn, u8aToBuffer, bufferToU8a } = require('@polkadot/util')
// const fs = require('fs')
// const path = require('path')
// const filename = path.join(__dirname, './types.json')
// const types = JSON.parse(fs.readFileSync(filename).toString())
const types = require('./types.json')
// const types = require('datdot-node-rust/types.json')
const b4a = require('b4a')

module.exports = datdotChain

async function datdotChain (profile) {
  const { name, config } = profile
  const provider = config.chain.join(':')
  const log = profile.log.sub('chain')

  // TODO: allow `datdot-chain` to spawn new or connect to existing chain node
  console.log({ profile_name: profile.name, name: log.path, type: '@todo', data: 'allow `datdot-chain` to spawn new or connect to existing chain node' })

  // provider = new WsProvider(`${address}:${port}`)
  const API = await ApiPromise.create({ name, provider, types, ondisconnect, log })
  // log({ type: 'chain', data: { text: 'got the API' } })
  const chainAPI = {
    getBlockNumber,
    newUser,
    registerForWork,
    publishFeed,
    publishPlan,
    unpublishPlan,
    amendmentReport,
    submitStorageChallenge,
    submitPerformanceChallenge,
    listenToEvents,
    getFeedByID,
    getPlanByID,
    getAmendmentByID,
    getContractByID,
    getStorageChallengeByID,
    getPerformanceChallengeByID,
    getItemByID,
    getFeedKey,
    getUserAddress,
    getUserIDByNoiseKey,
    getUserIDBySigningKey,
    getHosterKey,
    getEncoderKey,
    getAttesterKey,
    getSigningKey,
    getUserByID,
    pause,
    unpause
  }

  return chainAPI

  async function status ({ events = [], status }) {
    if (status.isInBlock) {
      events.forEach(({ phase, event: { data, method, section } }) => {
        log({ type: 'chainAPI', data: ['\t', phase.toString(), `: ${section}.${method}`, data.toString()] })
      })
    }
  }

  function ondisconnect (err) {
    log({ type: 'chain', data :{ text: 'chain disconnect', err: JSON.stringify(err) } })
    log({ type: 'chain', data :{ text: 'exit' } })
    process.exit()
  }

  async function getBlockNumber () {
    const header = await API.derive.chain.getHeader()
    return header.number
  }

  async function makeNonce (nonce) {
    const NONCE = await API.createType('Index', nonce)
    return { nonce: NONCE }
  }
  async function newUser ({ signer, nonce, data }) {
    const tx = await API.tx.datVerify.newUser(data)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function registerForWork ({ form, signer, nonce }) {
    // hosterkey = bufferToU8a(hosterkey)
    const tx = await API.tx.datVerify.registerForWork(form)
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function publishFeed (opts) {
    const { merkleRoot, signer, nonce } = opts
    //   merkleRoot[0] = bufferToU8a(merkleRoot[0])
    const tx = await API.tx.datVerify.publishFeed(merkleRoot)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function publishPlan (opts) {
    const { data, signer, nonce } = opts
    const tx = await API.tx.datVerify.publishPlan(data)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function unpublishPlan ({ planID, signer, nonce }) {
    const tx = await API.tx.datVerify.unpublishPlan(planID)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function getFeedKey (feedID) {
    // const feed = (await API.query.datVerify.getFeedByID(feedID)).unwrap()
    // return u8aToBuffer(feed.publickey.toU8a())
    const feed = (await API.query.datVerify.getFeedByID(feedID))
    return b4a.from(feed.feedkey, 'hex')
  }
  async function getItemByID (id) {
    // const feed = (await API.query.datVerify.getItemByID(id)).unwrap()
    return await API.query.datVerify.getItemByID(id)
  }
  async function getFeedByID (feedID) {
    // const feed = (await API.query.datVerify.getFeedByID(feedID)).unwrap()
    const feed = (await API.query.datVerify.getFeedByID(feedID))
    feed.feedkey = b4a.from(feed.feedkey, 'hex')
    return feed
  }
  async function getUserByID (id) {
    const user = await API.query.datVerify.getUserByID(id)
    return user
  }
  async function getUserIDByNoiseKey (key) {
    // const user = (await API.query.datVerify.getUserByID(id)).unwrap()
    // return user.address.toString()
    return await API.query.datVerify.getUserIDByNoiseKey(key)
  }
  async function getUserIDBySigningKey (key) {
    // const user = (await API.query.datVerify.getUserByID(id)).unwrap()
    // return user.address.toString()
    return await API.query.datVerify.getUserIDBySigningKey(key)
  }
  async function getUserAddress (id) {
    // const user = (await API.query.datVerify.getUserByID(id)).unwrap()
    // return user.address.toString()
    const user = await API.query.datVerify.getUserByID(id)
    return user.address
  }
  async function getSigningKey (id) {
    const user = (await API.query.datVerify.getUserByID(id))
    return b4a.from(user.signingKey, 'hex')
  }
  async function getHosterKey (id) {
    const user = (await API.query.datVerify.getUserByID(id))
    return b4a.from(user.noiseKey, 'hex')
  }
  async function getEncoderKey (id) {
    // return u8aToBuffer(user.noise_key.toU8a().slice(1))
    const user = (await API.query.datVerify.getUserByID(id))
    return b4a.from(user.noiseKey, 'hex')
  }
  async function getAttesterKey (id) {
    // const user = (await API.query.datVerify.getUserByID(id)).unwrap()
    // return u8aToBuffer(user.noise_key.toU8a().slice(1))
    const user = (await API.query.datVerify.getUserByID(id))
    return b4a.from(user.noiseKey, 'hex')
  }
  async function getContractByID (id) {
    // return (await API.query.datVerify.getContractByID(id)).toJSON()
    return await API.query.datVerify.getContractByID(id)
  }
  async function getAmendmentByID (id) {
    // return (await API.query.datVerify.getAmendmentByID(id)).toJSON()
    return await API.query.datVerify.getAmendmentByID(id)
  }
  async function getPlanByID (id) {
    // return (await API.query.datVerify.getPlanByID(id)).toJSON()
    return await API.query.datVerify.getPlanByID(id)
  }
  async function getStorageChallengeByID (id) {
    // return (await API.query.datVerify.getStorageChallengeByID(id)).toJSON()
    return await API.query.datVerify.getStorageChallengeByID(id)
  }
  async function getPerformanceChallengeByID (id) {
    // return (await API.query.datVerify.getPerformanceChallengeByID(id)).toJSON()
    return await API.query.datVerify.getPerformanceChallengeByID(id)
  }
  async function amendmentReport (opts) {
    const { report, signer, nonce } = opts
    const tx = await API.tx.datVerify.amendmentReport(report)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function pause (opts) {
    const { status, until, signer, nonce } = opts
    const tx = await API.tx.datVerify.pause(status, until)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function unpause (opts) {
    const { signer, nonce } = opts
    const tx = await API.tx.datVerify.unpause()
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function submitStorageChallenge (opts) {
    const { response, signer, nonce } = opts
    const tx = await API.tx.datVerify.submitStorageChallenge(response)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  async function submitPerformanceChallenge (opts) {
    const { challengeID, reports, signer, nonce } = opts
    const tx = await API.tx.datVerify.submitPerformanceChallenge(challengeID, reports)
    // tx.signAndSend(signer, await makeNonce(nonce))
    tx.signAndSend(signer, await makeNonce(nonce), status)
  }
  // LISTEN TO EVENTS
  async function listenToEvents (handleEvent) {
    return API.query.system.events((events) => {
      events.forEach(async (record) => {
        log({ new_event: record.event.method, data:record.event.data.toString() })
        const event = record.event
        handleEvent(event)
      })
    })
  }
}
