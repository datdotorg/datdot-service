const WebSocket = require('ws')

const handlers = []
const requests = []
const blockSubscribers = []
var instance = void 0
var retry_counter = 20

module.exports = {
  create: async ({ name, provider, ondisconnect, log }) => {
    if (typeof provider !== 'string') throw new Error('provider is not a fake chain')
    var header = { number: 0 }
    const api = ({
      query: {
        system: { events: handler => handlers.push(handler) },
        datVerify: {
          getItemByID: getItemByID.bind(name),
          getUserByID: getUserByID.bind(name),
          getUserIDByNoiseKey: getUserIDByNoiseKey.bind(name),
          getUserIDBySigningKey: getUserIDBySigningKey.bind(name),
          getFeedByID: getFeedByID.bind(name),
          getFeedByKey: getFeedByKey.bind(name),
          getPlanByID: getPlanByID.bind(name),
          getAmendmentByID: getAmendmentByID.bind(name),
          getContractByID: getContractByID.bind(name),
          getStorageChallengeByID: getStorageChallengeByID.bind(name),
          getPerformanceChallengeByID: getPerformanceChallengeByID.bind(name),
        }
      },
      createType: (nonce) => nonce,
      tx: { datVerify: {
        newUser: newUser.bind(name),
        registerForWork: registerForWork.bind(name),
        publishFeed: publishFeed.bind(name),
        publishPlan: publishPlan.bind(name),
        amendmentReport: amendmentReport.bind(name),
        submitStorageChallenge: submitStorageChallenge.bind(name),
        submitPerformanceChallenge: submitPerformanceChallenge.bind(name)
        }
      },
      rpc: {
        chain: { subscribeNewHeads: handle => blockSubscribers.push(handle) }
      },
      derive: {
        chain: { getHeader: () => header }
      }
    })
    var init
    if (instance) throw new Error('only one fakechain API per process')
    instance = { name, counter: 0, api }
    return new Promise(connect)
    function connect (resolve, reject) {
      log({ type: 'simulate', data: { text: 'connecting to chain' } })
      var ws = new WebSocket(provider)
      instance.ws = ws
      instance.send = send
      function send (message) { ws.send(JSON.stringify(message)) }
      ws.on('message', function incoming (message) {
        const { cite, type, data } = JSON.parse(message)
        if (type === 'block') {
          header = data
          return blockSubscribers.forEach(handle => handle(data))
        }
        if (!cite) return handlers.forEach(handle => handle(data))
        const [name, msgid] = cite[0]
        const resolve = requests[msgid]
        resolve(data)
      })
      ws.on('open', function open () {   
        if (instance.backlog) {
          if (instance.backlog.length) {
            log({ type: 'info', data: `flushing message buffer to chain` })
            instance.backlog.forEach(args => send(...args))
          }
          instance.backlog = null
          instance.send = send
          retry_counter = 20
        }

        // PROBLEM:
        // 1. a transaction/extrinsic gets scheduled into mempool for execution before
        // 2. the chainjs websocket receives an open event.
        // 3. at this moment, the counter and name property are still undefined 
        // 4. ... why are transactions being send before the chain is initialized?
        // 5. ... how can this be solved by either adding the required instance property earlier
        // 6. ... or waiting longer until the open websocket message was triggered

        if (init) return
        init = true
        resolve(api)
      })
      ws.on('error', function error (err) {
        const { errno, code, syscall, address, port, message } = err
        log({ type: 'error', data: { message, errno, code, syscall, address, port } })
        log({ type: 'info', data: 'disconnecting from chain' })
        ws.close('custom close')
      })
      ws.on('close', function close (data) { reconnect(data, resolve, reject) })
    }
    function reconnect (data, resolve, reject) {
      if (!retry_counter) return ondisconnect({ type: 'fail', data: 'chain connection retry exhausted' })
      retry_counter--
      log({ type: 'info', data })
      log({ type: 'info', data: `disconnected from chain` })
      log({ type: 'info', data: `trying to reconnect to chain`, retry_counter })
      log({ type: 'todo', data: `(replace backlog with hypercore)` })
      if (!instance.backlog) {
        instance.backlog = []
        instance.send = (...args) => {
          log({type: 'info', data: `buffering chain message` })
          instance.backlog.push(args)
          if (instance.backlog.length > 100) {
            log({ type: 'warn', data: `too many message without connection to chain` })
          }
        }
      }
      const miliseconds = randomIntFromInterval(500, 1500)
      setTimeout(() => { // TODO: implement better backoff strategy
        connect(resolve, reject)
      }, miliseconds)
    }
  }
}
function randomIntFromInterval (min, max) { // min and max included 
  return Math.floor(Math.random() * (max - min + 1) + min)
}
/******************************************************************************
  TRANSACTIONS (=EXTRINSICS)
******************************************************************************/
async function newUser (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'newUser' }) } }
async function registerForWork (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'registerForWork' }) } }
async function publishFeed (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'publishFeed'}) } }
async function publishPlan (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'publishPlan'}) } }
async function amendmentReport (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'amendmentReport'}) } }
async function submitStorageChallenge (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'submitStorageChallenge'}) } }
async function submitPerformanceChallenge (...args) { return { signAndSend: signAndSend.bind({ name: this, args, type: 'submitPerformanceChallenge'}) } }
/******************************************************************************
  QUERIES
******************************************************************************/
function getItemByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getItemByID', data: id })
  })
}
function getFeedByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getFeedByID', data: id })
  })
}
function getFeedByKey (key) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getFeedByKey', data: key })
  })
}
function getUserByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getUserByID', data: id })
  })
}
function getUserIDByNoiseKey (key) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getUserIDByNoiseKey', data: key })
  })
}
function getUserIDBySigningKey (key) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getUserIDBySigningKey', data: key })
  })
}
function getPlanByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getPlanByID', data: id })
  })
}
function getAmendmentByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getAmendmentByID', data: id })
  })
}
function getContractByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getContractByID', data: id })
  })
}
function getStorageChallengeByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getStorageChallengeByID', data: id })
  })
}
function getPerformanceChallengeByID (id) {
  const name = this
  return new Promise(resolve => {
    const msgid = instance.counter++
    const flow = [instance.name, msgid]
    requests[msgid] = resolve
    instance.send({ flow, type: 'getPerformanceChallengeByID', data: id })
  })
}

/******************************************************************************
  ROUTING (sign & send)
******************************************************************************/
function signAndSend (signer, { nonce }, status) {
  const { name, type, args } = this
  status({ events: [], status: { isInBlock:1 } })
  const msgid = instance.counter++
  const flow = [instance.name, msgid]
  requests[msgid] = status
  const address = signer.address
  const message = { flow, type, data: {type, args, nonce, address } }
  instance.send(message)
}
