const crypto = require("hypercore-crypto")
const tree = require('flat-tree')
const sodium = require('sodium-universal')
const derive_seed = require('derive-key')
const { Keyring } = require('@polkadot/api')
const keyring = new Keyring({ type: 'sr25519' })
const { seedKeygen } = require('noise-peer')
const brotli = require('brotli')
const parse_decompressed = require('parse-decompressed')

module.exports = {
  random_bytes,
  create_signing_keypair,
  create_chain_keypair,
  create_noise_keypair,
  derive_seed,
  verify_signature,
  verify_chunk_hash,
  merkle_verify,
}

function random_bytes (size) { // make sure this is high-entropy master key, eg. from a CSPRNG
  return crypto.randomBytes(size)
}

function create_signing_keypair ({ namespace, seed, name }) {
  const signingPublicKey = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES)
  const signingSecretKey = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES)
  const signingSeed = derive_seed(namespace, seed, name)
  sodium.crypto_sign_seed_keypair(signingPublicKey, signingSecretKey, signingSeed)
  return { signingPublicKey, signingSecretKey }
}

function create_chain_keypair ({ namespace, seed, name }) {
  const accountSecret = derive_seed(namespace, seed, name)
  const accountUri = `0x${accountSecret.toString('hex')}`
  return keyring.addFromUri(accountUri)
}

function create_noise_keypair ({ namespace, seed, name }) {
  const noiseSeed = derive_seed(namespace, seed, name)
  return seedKeygen(noiseSeed)
}

function verify_signature (signature, message, signingPublicKey) {
  // return crypto.verify(message, signature, signingPublicKey)
  return sodium.crypto_sign_verify_detached(signature, message, signingPublicKey)
}

async function verify_chunk_hash (index, encoded, nonce, nodes) {
  return new Promise(async (resolve, reject) => {
    const decompressed = await brotli.decompress(encoded)
    const decoded = parse_decompressed(decompressed, nonce)
    const node = nodes.find(node => node.index === index * 2)
    const hash = crypto.data(decoded)
    if (Buffer.compare(node.hash, hash)) reject()
    // console.log('Data hash verified')
    resolve()
  })
}

function merkle_verify ({feedKey, hash_index, version, signature, nodes}) {
  var next = nodes.find(node => node.index === hash_index)
  const roots = tree.fullRoots(version*2)
  roots.push(version*2)
  while (!roots.includes(next.index)) {
    const sibling_index = tree.sibling(next.index)
    const parent_index = tree.parent(next.index)
    next = hash_pair(nodes, next, sibling_index, parent_index)
  }
  const root_node = nodes.find(node => node.index === next.index)
  if (Buffer.compare(next.hash, root_node.hash)) return 'all hashes up to root not verified'
  if (!verify(nodes, roots, signature, feedKey, version)) return'checksum not verified'
  
  function hash_pair (nodes, next, sibling_index, parent_index) {
    const sibling = nodes.find(node => node.index === sibling_index)
    // console.log({next, sibling})

    const parent_hash = crypto.parent(next, sibling)
    const parent = {
      index: parent_index,
      hash: parent_hash,
      size: next.size + sibling.size
    }
    return parent
  }

  function verify (nodes, roots, signature, feedKey, version) {
    for (var i = 0, len = roots.length; i < len; i++) {
      nodes.find(node => { 
        if (node.index === roots[i]) {
          roots[i] = node
        }
      })
    }
    const checksum = crypto.signable(roots, version+1)
    return crypto.verify(checksum, signature, feedKey)
  }
}

// @NOTE:
// check comments in this commit https://github.com/playproject-io/datdot-service/blob/wip/src/vault.js