const intercept = require('_datdot-service-helpers/intercept-hypercore-storage')
const brotli = require('_datdot-service-helpers/brotli')
const parse_decompressed = require('_datdot-service-helpers/parse-decompressed')

const ENCODED_DATA_PREFIX = 0
const DECODED_PREFIX = 1
const ENCODED_DATA_SIGNATURE_PREFIX = 2
const UNIQUE_EL_PREFIX = 3
var stuff = { storeEnc: [], storeDec: [], getEnc: [], getDec: [] }

module.exports = class hosterStorage {
  /**
  brotli is an object with `async encode(rawData)` and `async decode(encodedData)`
  db is a levelup instance
  feed is a hypercore instance that will be used to store / seed the hosted hypercore
  **/
  constructor ({ db, feed, log }) {
    this.db = db
    this.log = log
    this.feed = feed
    this.unintercept = intercept(feed, {
      getData: async (index) => {
        const data = await this.getData(index)
        log({ type: 'hoster storage', data: { text: 'intercept get data', index, data }})
        return data 
      },
      putData: async (index, data, offset) => {
        log({ type: 'hoster storage', data: { text: 'intercept put data', index, offset, data}})
        await this.putData(index, data, offset)
      }
    })
  }

  // Invoked by the encoder so that the host will store the encoded data
  async storeEncoded ({ index, encoded_data_signature, encoded_data, unique_el }) {
    try {
      // index, encoded_data, signed_data
      // this.log({ type: 'hoster', data: { text: `Hoster storage - starting to store`, index, encoded_data }})
      // Get the decoded data at the index
      // In parallel, decode the encoded data
      const decompressed = await brotli.decompress(encoded_data)
      const decoded = parse_decompressed(decompressed, unique_el)
      // this.log({ type: 'storage', data: { text: `Getting decoded before storing`, decoded }})
      stuff.storeEnc[index] = encoded_data
      stuff.storeDec[index] = decoded
  
      // If it's the same save the encoded data
      // and delete the decoded data if it exists
      await this._putEncodedData(index, encoded_data)
      await this._delDecoded(index)
      await this._putEncodedDataSignature(index, encoded_data_signature)
      await this._putUniqueEl(index, Buffer.from(unique_el, 'binary'))
      this.log({ type: 'hoster-storage', data: [`chunk ${index} stored`]})
    } catch (err) {
      this.log({ type: 'Error', data: { text: 'Error: storing encoded data failed', err }})
    }
  }

  // Invoked by whoever to test that the hoster is actually hosting stuff
  async getProofOfStorage (index) {
    const [encoded_data, encoded_data_signature] = await Promise.all([
      this._getEncodedData(index),
      this._getEncodedDataSignature(index),
    ])
    return {
      feedKey: this.feed.key,
      index,
      encoded_data,
      encoded_data_signature,
    }
  }

  // Meant to be used by the hypercore storage
  async getData (index) {
    this.log({ type: 'hoster-storage', data: { text: 'getData intercepted', index }})
    var decoded
    try {
      const encoded_data = await this._getEncodedData(index)
      // Got encoded data!
      // Decode and return it
      const enc = stuff.storeEnc[index]
      const dec = stuff.storeDec[index]
      // TODO: (maybe it's ok)
      const decompressed = await brotli.decompress(encoded_data)
      const unique_el = await this._getUniqueEl(index)
      decoded = parse_decompressed(decompressed, unique_el)
      this.log({ type: 'hoster-storage', data : { text: 'got data for', index, decoded } })
      return decoded
    } catch (error) {
      // Key doesn't exist? Try to get decoded version
      this.log({ type: 'hoster-storage', data: { text: 'encoded not yet stored', index }})
      try {
        // If it exists, return it
        decoded = await this._getDecoded(index)
        this.log({ type: 'hoster-storage', data: { text: 'got decoded for', index, decoded } })
        return decoded
        // If we got the value, send it to the CB
      } catch(error) {
        this.log({ type: 'Error', data: { text: 'Error getting decoded', index }})
        throw error
      }
    }
  }

  // Meant to be used by the hypercore storage
  async putData (index, data, offset) {
    // this.log({ type: 'hoster-storage', data: { text: 'putData intercepted', index }})
    // Check if encoded data exists
    try {
      const decoded = await this._getDecoded(index)
      // We already have the encoded version so whatever
      this.log({ type: 'hoster-storage', data: { text: 'have encoded, now store decoded', index }})
      return
    } catch (error) {
      // We don't have the encoded version so we should store the decoded version
      try {
        await this._putDecoded(index, data)
        this.log({ type: 'hoster-storage', data: { text: `no encoded, store decoded`, index }})
        return
      } catch (err) {
        this.log({ type: 'hoster-storage', data: { text: `Error in putData`, index, err }})
        throw err
      }
    }
  }

  async _getEncodedData (index) {
    try {
      return this.db.get(makeKey(ENCODED_DATA_PREFIX, index))
    } catch(err) {
      this.log({ type: 'Error in _getEncodedData', data: err})
    }
  }
  async _getDecoded (index) {
    try {
      return this.db.get(makeKey(DECODED_PREFIX, index))
    } catch(err) {
      this.log({ type: 'Error in _getDecoded', data: err})
    }
  }
  async _getEncodedDataSignature (index) {
    try {
      return this.db.get(makeKey(ENCODED_DATA_SIGNATURE_PREFIX, index))
    } catch(err) {
      this.log({ type: 'Error in _getEncodedDataSignature', data: err})
    }
  }
  async _getUniqueEl (index) {
    try {
      return this.db.get(makeKey(UNIQUE_EL_PREFIX, index))
    } catch(err) {
      this.log({ type: 'Error in _getUniqueEl', data: err})
    }
  }

  async _putEncodedData (index, data) {
    return this.db.put(makeKey(ENCODED_DATA_PREFIX, index), data, Buffer.from([0, 255]), err => {
      if (err) this.log({ type: 'Error', data: { text: '_putEncodedData', err } })
    })
  }
  async _putDecoded (index, data) {
    return this.db.put(makeKey(DECODED_PREFIX, index), data, Buffer.from([0, 255]), err => {
      if (err) this.log({ type:'fail', data: { text: '_putDecoded', err } })
    })
  }
  async _putEncodedDataSignature (index, proof) {
    return this.db.put(makeKey(ENCODED_DATA_SIGNATURE_PREFIX, index), proof, Buffer.from([0, 255]), err => {
      if (err) this.log({ type: 'Error', data: { text: '_putEncodedDataSignature', err } })
    })
  }
  async _putUniqueEl (index, data) {
    return this.db.put(makeKey(UNIQUE_EL_PREFIX, index), data, Buffer.from([0, 255]), err => {
      if (err) this.log({ type: 'Error', data: { text: '_putUniqueEl', err} })
    })
  }

  async _delDecoded (index) {
    try {
      await this.db.del(makeKey(DECODED_PREFIX, index))
    } catch {
      // Whatever, it's probably not saved
    }
  }

  async close () {
    await this.feed.close()
    await this.discovery.destroy()
    await this.db.close()
  }
  
  async destroy (log) {
    log({ type: 'feed', data: { text: 'Destroy discovery and close feed and db' }})
    await this.feed.close()
    await this.discovery.destroy()
    await this.db.clear()
    await this.db.close()
  }
}

function makeKey (type, index) {
  // Allocate a buffer that holds enough for the type and the index
  const typedKey = new Uint32Array(2)

  typedKey[0] = type
  typedKey[1] = index

  return Buffer.from(typedKey.buffer)
}