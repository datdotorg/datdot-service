const hyperswarm = require('hyperswarm')
const hypercore = require('hypercore')
const HypercoreProtocol = require('hypercore-protocol')
const RAM = require('random-access-memory')
const FeedStorage = require('_datdot-service-helpers/feed-storage.js')
const register_extension = require('_datdot-service-helpers/register-extension')
const ready = require('_datdot-service-helpers/hypercore-ready')
const sub = require('subleveldown')
const datdot_crypto = require('../datdot-crypto') 

module.exports = load_feed

async function load_feed ({ targets, role, account, feedkey, onmessage, onerror, log }) {
    const swarmmode = (role === 'author') ? { server: true, client: false } : { server: false, client: true }
    if (role === 'hoster') {
        const opts = ({ keyPair: { publicKey: account.noisePublicKey, secretKey: account.noisePrivateKey } })
        return setup('hosting', opts, swarmmode)
    }
    if (role === 'encoder' || role === 'sponsor') return setup('general', {}, swarmmode)
    if (role === 'attestor-challenge' || role === 'author') { return setup('temp', {}, swarmmode) }
    /* 
    account.cache[mode] = {
        swarm,
        sockets: {
            remotekey: { 
                socket, 
                replicationStream
            }
        },
        topics: {
            stringtopic: {
                discovery,
                feeds: {
                    stringkey: { feed }
                },
                sockets: {
                    remotekey: account.cache[mode].sockets[remotekey]
                }
            }
        }
    }
    */

    async function setup (mode, opts, swarmmode) {
        var swarm
        var feed
        if (mode === 'temp') { 
            feed = new hypercore(RAM, { valueEncoding: 'binary' })
            await ready(feed)
            feedkey = feed.key
        }
        const stringkey = feedkey.toString('hex')
        const topic = datdot_crypto.get_discoverykey(feedkey)
        const stringtopic = topic.toString('hex')

        // no cache yet for this mode
        if (!account.cache[mode]) {
            account.cache[mode] = { sockets: {}, topics: {} }
        }
        // no topic yet
        const cache = account.cache[mode]
        if (!cache.topics[stringtopic]) {
            cache.topics = { [stringtopic]: { feeds: {}, sockets: {} } }
        }
        // no feed yet
        const feeds = cache.topics[stringtopic].feeds
        if (!feeds[stringkey]) {
            if (!feed) feed = new hypercore(RAM, feedkey, { valueEncoding: 'binary', sparse: true })
            feeds[stringkey] = { feed }
        }
        // no ext
        if (!cache.topics[stringtopic].ext) {
            cache.topics[stringtopic].ext = register_extension(feeds[stringkey].feed, `datdot-hoster-${stringkey}`, onmessage, onerror)
        }
        
        // no swarm yet
        if (!cache.swarm) {
            swarm = new hyperswarm(opts)
            cache.topics[stringtopic].discovery = swarm.join(topic, swarmmode)
            swarm.on('connection', onconnection(account.cache[mode]))
        }
        return feeds[stringkey].feed
    }
    
    
    function onconnection (cache) {
        const { swarm, sockets, topics } = cache
        return (connection, info) => {
            const remotekey = connection.remotePublicKey
            const remotestringkey = remotekey.toString('hex')
            var socket = sockets[remotestringkey]
            if (socket) return // see if this connection is already in use
            log({ type: 'load-feed', data: { text: 'onconnection', remotestringkey, isInitiator: connection.isInitiator } })

            const replicationStream = new HypercoreProtocol(connection.isInitiator)
            socket = { socket: connection, replicationStream }
            connection.pipe(replicationStream).pipe(connection)
            // log({ type: 'swarm', data: { text: `New connection`, socket: socket.isInitiator  } })
            // next({ ext, feed, remotekey, log })
            if (info.topics.length) {
                log({ type: 'load-feed', data: { text: 'topics', topics: info.topics, isInitiator: connection.isInitiator } })
                for (var i = 0, len = info.topics.length; i < len; i++) {
                    const Topic = info.topics[i].toString('hex')
                    if (topics[Topic]) {
                        var topics_socket = topics[Topic].sockets[remotestringkey]
                        if (!topics_socket) topics_socket = socket
                        Object.keys(topics[Topic].feeds).forEach(key => {
                            const { feed } = topics[Topic].feeds[key]
                            log({ type: 'load-feed', data: { text: 'matching topic', topic: Topic } })
                            feed.replicate(replicationStream)
                        }) 
                    }
                }
            } else {
                replicationStream.on('discovery-key', (discoverykey) => { // client hasn't replicated the hypercores so they are asking for the 'discovery-key' event
                    console.log('discovery key')
                    const Topic = discoverykey.toString('hex')
                    if (topics[Topic]) { 
                        var topics_socket = topics[Topic].sockets[remotestringkey]
                        if (!topics_socket) topics_socket = socket
                        Object.keys(topics[Topic].feeds).forEach(key => {
                            const { feed } = topics[Topic].feeds[key]
                            log({ type: 'load-feed', data: { text: 'matching topic', topic: Topic } })
                            feed.replicate(replicationStream)
                        }) 
                    }
                })
            }
        }
    }

        // const protocolStream = new HypercoreProtocol(socket.isInitiator)
        // socket.pipe(protocolStream).pipe(socket)
        // log({ type: 'swarm', data: { text: `New connection`, socket: socket.isInitiator  } })
        // clearTimeout(tid) // clear retry timeout
        // const keys = Object.keys(account.cache)
        // console.log({ text: 'keys in cache', keys})
        // for (var i = 0, len = keys.length; i < len; i++) {
        //     const stringkey = keys[i]
        //     const task_ids = Object.keys(account.cache[stringkey].tasks)
        //     task_ids.forEach(id => account.cache[stringkey].tasks[id].onconnection(socket, protocolStream))
        // }
        // socket.on('error', (err) => { log({ type: 'swarm', data: { text: `Socket on error`, err } })})
        // socket.on('end', () => { log({ type: 'swarm', data: { text: `Socket on end` } })})
        // socket.on('close', () => { log({ type: 'swarm', data: { text: `Socket on close` } })})
        // protocolStream.on('end', () => { log({ type: 'swarm', data: { text: `protocolStream on end` } })})
        // protocolStream.on('close', () => { log({ type: 'swarm', data: { text: `protocolStream on close` } })})   







    // if (account.cache[stringkey]) {
    //     feed = account.cache[stringkey].feed
    //     log({ type: role, data: { text: `Existing feed`, key: feed.key.toString('hex') } })
    //     if (role === 'hoster') {
    //         ext = account.cache[stringkey].ext
    //         if (!ext) {
    //             ext = feed.registerExtension(name, { encoding: 'binary ', onmessage, onerror  })
    //             log({ type: role, data: { text: `New extension`, stringkey } })
    //             account.cache[stringkey].ext = ext
    //         } else log({ type: role, data: { text: `Existing extension`, stringkey } })
    //         if (!account.storages.has(stringkey)) {
    //             log({ type: role, data: { text: `New storage for feed, existing cache`, stringkey } })
    //             const db = sub(account.db, stringkey, { valueEncoding: 'binary' })
    //             const storage = new FeedStorage({ db, feed, log })
    //             account.storages.set(stringkey, storage)
    //         }
    //     }
    //     account.cache[stringkey].tasks[task_id] = { onconnection, log }
    // } else {
    //     feed = new hypercore(RAM, feedkey, { valueEncoding: 'binary', sparse: true })
    //     await ready(feed)
    //     feed.on('error', async (err) => log({ type: 'feed', data: { text: 'feed: error', err } }))
    //     const mode = { server: false, client: true }
    //     discovery = await swarmAPI.join_topic({ swarmAPI, feed, role, account, mode, log })
    //     if (role === 'hoster') {
    //         log({ type: role, data: { text: `New storage for feed, new cache`, stringkey } })
    //         const db = sub(account.db, stringkey, { valueEncoding: 'binary' })
    //         const storage = new FeedStorage({ db, feed, log })
    //         account.storages.set(stringkey, storage)
            
    //         ext = feed.registerExtension(name, { encoding: 'binary ', onmessage, onerror  })
    //         log({ type: role, data: { text: `New feed, new extension`, key: feed.key.toString('hex') } })
    //     } else log({ type: role, data: { text: `New feed`, stringkey } })
    //     console.log({ text: 'load_feed', feed })
    //     account.cache[stringkey] = { feed, discovery, ext, tasks: { task_id: { onconnection, log } }, log }
    // }

    // async function onconnection (socket, protocolStream) {
    //     const remotekey = socket.remotePublicKey
    //     const remotestringkey = remotekey.toString('hex')
    //     log({ type: role, data: { text: `onconnection callback`, role, task_id, feed: feed.key.toString('hex'), socket: socket.isInnitiator, remotestringkey, targets  } })
    //     if (targets) {
    //         var targets_copy = [...targets]
    //         log({ type: role, data: { text: `Target IDs`, targets  } })
    //         for (var i = 0, len = targets_copy.length; i < len; i++) {
    //             const hosterID = targets_copy[i]
    //             const hosterkey = await chainAPI.getHosterKey(hosterID)
    //             log({ type: 'attestor challenge', data: { text: `Comparing keys`, hosterID, peer: remotekey.toString('hex'), hoster: hosterkey.toString('hex') } })
    //             if (remotekey.equals(hosterkey)) {
    //                 log({ type: role, data: { text: `Calling next with hosterID`, role, id: hosterID, feed: feed.key.toString('hex')  } })
    //                 feed.replicate(protocolStream)
    //                 targets_copy.splice(i, 1)
    //                 return next({ feed, hosterID, remotekey, log })
    //             }
    //         } 
    //     } else {
    //         log({ type: role, data: { text: `Calling next`, role, len: feed.length, ext: !ext ? 'undefined' : 'extension'   } })
    //         feed.replicate(protocolStream)
    //         next({ ext, feed, remotekey, log })
    //     }
    // }

}
