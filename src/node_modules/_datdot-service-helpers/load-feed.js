const hyperswarm = require('hyperswarm')
const hypercore = require('hypercore')
const RAM = require('random-access-memory')
const FeedStorage = require('_datdot-service-helpers/feed-storage.js')

const sub = require('subleveldown')
const ready = require('_datdot-service-helpers/hypercore-ready')


module.exports = load_feed

async function load_feed ({ newfeed, targets, role, swarmAPI, chainAPI, task_id, account, feedkey, next, onmessage,  log }) {
    const stringkey = feedkey.toString('hex')
    const name = `datdot-hoster-${stringkey}`
    var feed
    var discovery
    var ext
    // if (newfeed) {
    //     feed = new hypercore(RAM, feedkey, { valueEncoding: 'binary', sparse: true })
    //     feed.on('error', async (err) => log({ type: 'feed', data: { text: 'feed: error', err } }))
    //     const discovery = await swarmAPI.join_topic({ swarmAPI, feed, role, account, mode: { server: false, client: true }, log })
    //     await storage.add_task(task_id, onconnection, log)
    // }
    if (account.cache[stringkey]) {
        feed = account.cache[stringkey].feed
        log({ type: role, data: { text: `Existing feed`, key: feed.key.toString('hex') } })
        if (role === 'hoster') {
            ext = account.cache[stringkey].ext
            if (!ext) {
                ext = feed.registerExtension(name, { encoding: 'binary ', onmessage, onerror  })
                log({ type: role, data: { text: `New extension`, stringkey } })
                account.cache[stringkey].ext = ext
            } else log({ type: role, data: { text: `Existing extension`, stringkey } })
            if (!account.storages.has(stringkey)) {
                log({ type: role, data: { text: `New storage for feed, existing cache`, stringkey } })
                const db = sub(account.db, stringkey, { valueEncoding: 'binary' })
                const storage = new FeedStorage({ db, feed, log })
                account.storages.set(stringkey, storage)
            }
        }
        account.cache[stringkey].tasks[task_id] = { onconnection, log }
    } else {
        feed = new hypercore(RAM, feedkey, { valueEncoding: 'binary', sparse: true })
        await ready(feed)
        feed.on('error', async (err) => log({ type: 'feed', data: { text: 'feed: error', err } }))
        discovery = await swarmAPI.join_topic({ swarmAPI, feed, role, account, mode: { server: false, client: true }, log })
        if (role === 'hoster') {
            log({ type: role, data: { text: `New storage for feed, new cache`, stringkey } })
            const db = sub(account.db, stringkey, { valueEncoding: 'binary' })
            const storage = new FeedStorage({ db, feed, log })
            account.storages.set(stringkey, storage)
            
            ext = feed.registerExtension(name, { encoding: 'binary ', onmessage, onerror  })
            log({ type: role, data: { text: `New feed, new extension`, key: feed.key.toString('hex') } })
        } else log({ type: role, data: { text: `New feed`, stringkey } })
        console.log({ text: 'load_feed', feed })
        account.cache[stringkey] = { feed, discovery, ext, tasks: { task_id: { onconnection, log } }, log }
    }

    async function onconnection (socket, protocolStream) {
        const remotekey = socket.remotePublicKey
        const remotestringkey = remotekey.toString('hex')
        log({ type: role, data: { text: `onconnection callback`, role, task_id, feed: feed.key.toString('hex'), socket: socket.isInnitiator, remotestringkey, targets  } })
        if (targets) {
            var targets_copy = [...targets]
            log({ type: role, data: { text: `Target IDs`, targets  } })
            for (var i = 0, len = targets_copy.length; i < len; i++) {
                const hosterID = targets_copy[i]
                const hosterkey = await chainAPI.getHosterKey(hosterID)
                log({ type: 'attestor challenge', data: { text: `Comparing keys`, hosterID, peer: remotekey.toString('hex'), hoster: hosterkey.toString('hex') } })
                if (remotekey.equals(hosterkey)) {
                    log({ type: role, data: { text: `Calling next with hosterID`, role, id: hosterID, feed: feed.key.toString('hex')  } })
                    feed.replicate(protocolStream)
                    targets_copy.splice(i, 1)
                    return next({ feed, hosterID, otherIsInitiator: socket.isInitiator, log })
                }
            } 
        } else {
            log({ type: role, data: { text: `Calling next`, role, len: feed.length, ext: !ext ? 'undefined' : 'extension'   } })
            feed.replicate(protocolStream)
            next({ ext, feed, otherIsInitiator: socket.isInitiator, log })
        }
    }

    // function onmessage (perf_sig,hosterKey) {
    //     extensions[name].callbacks.forEach(done => done(null, perf_sig, hosterKey))
    // }
    function onerror (err/* peerSocket???*/) {
        // TODO: disconnect from peer
        log({ type: 'fail', data: 'err extension message' })   
    }
}
