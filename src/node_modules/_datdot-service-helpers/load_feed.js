const hyperswarm = require('hyperswarm')
const hypercore = require('hypercore')
const RAM = require('random-access-memory')
const { finished } = require('stream')

const sub = require('subleveldown')
const HosterStorage = require('_datdot-service-helpers/hoster-storage.js')
const ready = require('_datdot-service-helpers/hypercore-ready')


module.exports = load_feed

async function load_feed (role, swarmAPI, account, feedkey, log) {
    const stringkey = feedkey.toString('hex')
    var counter = 10
    var tid
    var feed
    var ext
    if (account.storages.has(stringkey)) {
        const storage = account.storages.get(stringkey)
        feed = storage.feed
        if (role === 'hoster') {
            ext = storage.ext
            if (!ext) {
                ext = feed.registerExtension(`datdot-hoster-${stringkey}`, { encoding: 'binary ' })
                log({ type: role, data: { text: `Existing feed, new extension`, stringkey } })
                storage.update(ext)
            } else log({ type: role, data: { text: `Existing feed, existing extension`, stringkey } })
        } 
        return { feed, ext }       
    } else {
        feed = new hypercore(RAM, feedkey, { valueEncoding: 'binary', sparse: true })
        await ready(feed)
        feed.on('error', async (err) => log({ type: 'feed', data: { text: 'feed: error', err } }))

        const db = sub(account.db, stringkey, { valueEncoding: 'binary' })
        const storage = new HosterStorage({ db, feed, log })
        account.storages.set(stringkey, storage)

        const mode = { server: false, client: true }
        const topic = feed.discoveryKey
        const discovery = swarmAPI.swarm.join(topic, mode)
        storage.update(discovery)
        log({ type: role, data: { text: `Swarm joined`, feedkey, topic } })

        retry(discovery, mode, log)
        swarmAPI.swarm.on('connection', async (socket) => onconnection(socket))

        if (role === 'hoster') {
            ext = feed.registerExtension('datdot-hoster', { encoding: 'binary ' })
            storage.update(ext)
            log({ type: role, data: { text: `New feed, new extension`, stringkey } })
        } else log({ type: role, data: { text: `New feed`, stringkey } })
        return { feed, ext }
    }
    

    async function onconnection (socket) {
        log({ type: role, data: { text: `onconnection`, role } })
        clearTimeout(tid)
        const stream = feed.replicate(socket.isInitiator)
        socket.pipe(stream).pipe(socket)
        log({ type: role, data: { feedkey: feed.key.toString('hex'), swarmkey: feed.discoveryKey.toString('hex') } })
    
        finished(stream, (err) => {
          if (err) {
            console.error('Stream failed.', err);
          } else {
            console.log('Stream finished, ending socket now')
            try { socket.end() }
            catch(err) { log({ type: role, data: { text: `Closing socket error`, err } }) }
          }
        })
    }

    async function retry (discovery, mode, log) {
        tid = setTimeout(() => {
            log({ type: 'feed', data: { text: 'retrying connection', role }})
            if (counter--) retry(discovery, mode, log)
        }, 1000)
        await discovery.refresh(mode)
    }
}
