const try_refresh_discovery = require('./try-refresh-discovery')
const b4a = require('b4a')

module.exports = {
	done_task_cleanup,
	clean_general_task,
	remove_from_roles,
	get_tasks_count_for_topic,
	close_feeds,
	remove_from_tasks,
	get_connections,
	remove_from_feeds,
	decrease_socket_count,
	remove_from_targets,
	get_socket_count,
	remove_from_sockets,
	close_streams_and_channels,
	get_target_tasks,
	remove_from_target_tasks,
	remove_from_task_connections,
	remove_from_registry,
	get_tasks,
	get_sockets,
	set_status_for_connection,
}

async function done_task_cleanup ({ role, topic, remotestringkey, state, log }) { // TODO: add remotestringkey when known
	const { swarm, sockets, feeds, targets, tasks } = state
	const stringtopic = topic.toString('hex')
	
	log({ 
		type: 'cleanup', 
		data: { 
			text: 'task done', 
			role, 
			stringtopic,
			remotestringkey,
			conn_for_topic: tasks[stringtopic] ? Object.keys(tasks[stringtopic].connections) : undefined, 
			conn: Object.keys(tasks).map(topic => [ topic, JSON.stringify(Object.keys(tasks[topic].connections))]), 
			sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ]),
			roles: get_tasks({ tasks, log }).map(stringtopic => tasks[stringtopic].roles),
			target_topics: targets && targets[remotestringkey] ? Object.keys(targets[remotestringkey].tasks) : undefined,
			tasks: Object.keys(tasks) 
		} 
	})

	if (tasks[stringtopic].connections[remotestringkey] === 'in cleanup') return
	set_status_for_connection({ status: 'in cleanup', tasks, stringtopic, remotestringkey})

	if (targets[remotestringkey] && targets[remotestringkey].tasks[stringtopic]) { // --------- TARGET -------------
		// TARGETS
		// stringtopic is one time used & is unique BUT !!!!
		// for performance-attesting we connect to many targets on same general topic

    // roles: attester2encoder, attester2hoster, performance_attester, storage_attester
		// performance_attester might also be hoster (or encoder) for same feed

		// performance attester calls done task multiple times for same performance challenge
		// first time we remove the task, so we need to check if task exists in all the other calls to avoid err
		if (tasks[stringtopic]) remove_from_roles({ tasks, role, stringtopic, log })
		remove_from_target_tasks({ targets, stringtopic, remotestringkey, log }) // we have always only one task per stringtopic for targets
		const target_tasks = get_target_tasks({ targets, remotestringkey, log })
		if (!target_tasks.length) {
			log({ type: 'cleanup', data: { text: 'remove from targets, remove registry', role, remotestringkey, stringtopic  }})
			remove_from_targets({ targets, remotestringkey, log })
			// remove_from_registry({ sockets, stringtopic, remotestringkey, log })
		}

		swarm.leavePeer(b4a.from(remotestringkey, 'hex')) // stop attempting direct connections to the peer
		if (tasks[stringtopic]) {
			if (role === 'performance_attester') {
				const topic_tasks = get_tasks_count_for_topic({ tasks, stringtopic, log })
				// TODO: leavePeer from topic, even if there still is a task for other stuff (like hoster role etc.)
				if (!topic_tasks) {
					remove_from_tasks({ tasks, stringtopic, log })
					const field = `${stringtopic}-${remotestringkey}`
					close_feeds({ feeds, field, log })
				}
			} else {
				remove_from_tasks({ tasks, stringtopic, log })
				close_feeds({ feeds, field: stringtopic, log })
			}
		}

		// SOCKETS
		decrease_socket_count({ sockets, remotestringkey, log })
		const connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
		if (!connections_for_socket) {
			close_streams_and_channels({ sockets, remotestringkey, log })
			remove_from_sockets({ sockets, remotestringkey, log })
		} 
	}
	else { // --------- NO TARGET/GENERAL SWARM -------------
		// roles: encoder, hoster or sponsor to author/anyone in general swarm
		await clean_general_task({ state, role, stringtopic, remotestringkey, log })
	}

	// set back to in progress if there is another same-topic task with this peer
	if (tasks[stringtopic]?.connections[remotestringkey]) {
		set_status_for_connection({ status: 'in progress', tasks, stringtopic, remotestringkey})
	}
	// other peer didn't get a socket onclose, so they need to know task is done && needs to be cleaned
	if (sockets[remotestringkey]) { 
		notify_to_close_task({ state, remotestringkey, stringtopic, role, log })
	}

  log({ type: 'on close', data: { 
    text: `cleanup finished`, 
		role, 
		stringtopic,
		remotestringkey,
		conn: tasks[stringtopic] ? Object.keys(tasks[stringtopic].connections) : undefined, 
		sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ]),
		roles: get_tasks({ tasks, log }).map(stringtopic => tasks[stringtopic].roles),
		tasks: Object.keys(tasks) 
  } }) 
}

// HELPERS

async function clean_general_task ({ state, role, stringtopic, remotestringkey, log }) {
	const { sockets, feeds, tasks, swarm } = state
	const topic = b4a.from(stringtopic, 'hex')
	
	remove_from_roles({ tasks, role, stringtopic, log })
	
	decrease_socket_count({ sockets, remotestringkey, log })
	
	
	const topic_tasks = get_tasks_count_for_topic({ tasks, stringtopic, log })
	const connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
	if (!connections_for_socket) {
		close_streams_and_channels({ sockets, remotestringkey, log })
		// same-topic tasks can be handled alongside another same-topic task
		// which means socket hasn't been incremented twice and when that task has been cleaned
		// sockets[remostringkeey] have been removed
		if (sockets[remotestringkey]) remove_from_sockets({ sockets, remotestringkey, log })
		if (tasks[stringtopic]?.connections[remotestringkey]) {
			remove_from_task_connections({ tasks, stringtopic, remotestringkey, log })
		}
	}

	if (!topic_tasks) {
		remove_from_tasks({ tasks, stringtopic, log })
		close_feeds({ feeds, field: stringtopic, log })
		swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
	} else {
		await try_refresh_discovery({ swarm, topic, tasks: tasks[stringtopic].roles, log }) 
	}
}

// STRINGTOPIC NEEDED
function remove_from_roles ({ tasks, role, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', role, stringtopic }})
	// author and hoster need to always be 'on'
	if (role === 'author' || role === 'hoster') return tasks[stringtopic].roles[role] = 1
	tasks[stringtopic].roles[`${role}`]--
	// if (tasks[stringtopic].roles[`${role}`] === 0) {
	// 	delete tasks[stringtopic].roles[`${role}`]
	// }
	// after `hoster2author` task is done, hoster gets a `hoster` role
	if (role === 'hoster2author') tasks[stringtopic].roles['hoster'] ? 
		tasks[stringtopic].roles['hoster']++ 
		: tasks[stringtopic].roles['hoster'] = 1
}
function get_tasks_count_for_topic ({ tasks, stringtopic, log }) {
	var count = 0
	Object.keys(tasks[stringtopic].roles).forEach(role => {
		count += tasks[stringtopic].roles[role]
	})
	return count
}
function close_feeds ({ feeds, field, log }) {
	const feedkeys = Object.keys(feeds[field])
	feedkeys.forEach(async key => {
		const { feed } = feeds[field][key]
		remove_from_feeds({ feeds, field, log })
		await feed.core.close()
	})
}
function get_tasks ({ tasks, log }) {
	return Object.keys(tasks)
}
function get_sockets ({ sockets, log }) {
	return Object.keys(sockets)
}
function remove_from_tasks ({ tasks, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', stringtopic }})
	delete tasks[stringtopic]
}
function get_connections ({ tasks, stringtopic, log }) {
	var connections = !tasks[stringtopic] ? [] : Object.keys(tasks[stringtopic].connections)
	return connections
}
function remove_from_feeds ({ feeds, field, log }) {
	if (!feeds[field]) return log({ type: 'cleanup', data: { text: 'error: no matching feeds', field }})
	delete feeds[field]
}

// REMOTESTRINGKEY NEEDED
function decrease_socket_count ({ sockets, remotestringkey, log }) { 
	sockets[remotestringkey].count-- 
}
function remove_from_targets ({ targets, remotestringkey, log }) {
	if (!targets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching target', remotestringkey }})
	delete targets[remotestringkey]
}
function get_socket_count ({ sockets, remotestringkey, log }) {
	return sockets[remotestringkey].count
}
function remove_from_sockets ({ sockets, remotestringkey, log }) {
	if (!sockets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching socket', remotestringkey }})
	delete sockets[remotestringkey]
}
function close_streams_and_channels ({ sockets, remotestringkey, log }) {
	const { socket, replicationStream, channel, mux } = sockets[remotestringkey]
	if (channel) channel.close()
	mux.unpair({ protocol: 'datdot/alpha' })
	mux.destroy()
	socket.destroy()
	replicationStream.destroy()	
}
function get_target_tasks ({ targets, remotestringkey, log }) {
	return Object.keys(targets[remotestringkey].tasks)
}

// STRINGTOPIC && REMOTESTRINGKEY NEEDED
function remove_from_target_tasks ({ targets, stringtopic, remotestringkey, log }) {
	const target_tasks = targets[remotestringkey].tasks
	if (!target_tasks) return log({ type: 'cleanup', data: { text: 'error: no target tasks', stringtopic, remotestringkey }})
	delete targets[remotestringkey].tasks[stringtopic] // there is only one task
}
function remove_from_task_connections ({ tasks, stringtopic, remotestringkey, log }) {
	if (!tasks[stringtopic].connections[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no connection', stringtopic, remotestringkey }})
	log({ type: 'cleanup', data: { type: `Remove from task connections`, remotestringkey, stringtopic } })
	delete tasks[stringtopic].connections[remotestringkey]
}
function remove_from_registry ({ sockets, stringtopic, remotestringkey, log }) {
	const msgs = sockets[remotestringkey].channel.messages
	for (const msg_type of msgs) {
		msg_type.registry.delete(stringtopic)
	}
}
function notify_to_close_task ({ state, remotestringkey, stringtopic, role, log }) {
	const channel = state.sockets[remotestringkey].channel
	const [string_msg] = channel.messages
	log({ type: 'cleanup', data: { text: 'sending msg done', role, remotestringkey, stringtopic }})
	string_msg.send(JSON.stringify({ type: 'done', stringtopic }))
}
function set_status_for_connection ({ status, tasks, stringtopic, remotestringkey}) {
	tasks[stringtopic].connections[remotestringkey] = status
}