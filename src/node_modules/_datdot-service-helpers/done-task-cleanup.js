const try_refresh_discovery = require('./try-refresh-discovery')
const b4a = require('b4a')

module.exports = {
	done_task_cleanup,
	clean_general_task,
	remove_from_roles,
	get_tasks_count_for_topic,
	close_feeds,
	remove_from_tasks,
	get_connections,
	remove_from_feeds,
	decrease_socket_count,
	remove_from_targets,
	get_socket_count,
	remove_from_sockets,
	close_streams_and_channels,
	get_target_tasks,
	remove_from_target_tasks,
	remove_from_task_connections,
	remove_from_registry,
	get_tasks,
	get_sockets,
	set_status_for_connection,
}

async function done_task_cleanup ({ role, topic, remotestringkey, peers, state, log }) { // TODO: add remotestringkey when known
	const { swarm, sockets, feeds, targets, tasks } = state
	const stringtopic = topic.toString('hex')
	var is_target_task
	
	log({ 
		type: 'cleanup', 
		data: { 
			text: 'task done', 
			role, 
      peers: peers ? peers : [],
			stringtopic,
			remotestringkey,
			conn_for_topic: tasks[stringtopic] ? Object.keys(tasks[stringtopic].connections) : undefined, 
			conn: Object.keys(tasks).map(topic => [ topic, JSON.stringify(Object.keys(tasks[topic].connections))]), 
			sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ]),
			roles: get_tasks({ tasks, log }).map(stringtopic => JSON.stringify(tasks[stringtopic].roles)),
			target_topics: targets && targets[remotestringkey] ? Object.keys(targets[remotestringkey].tasks) : undefined,
			tasks: Object.keys(tasks) 
		} 
	})

  
	// --------- TARGET -------------
	if (targets[remotestringkey] && targets[remotestringkey].tasks[stringtopic]) { 
    if (tasks[stringtopic].connections[remotestringkey] === 'in cleanup') return
    set_status_for_connection({ status: 'in cleanup', tasks, stringtopic, remotestringkey})
		is_target_task = true
		// stringtopic is one time used & is unique BUT !!!!
		// for performance-attesting we connect to many targets on same general topic

    // roles: attester2encoder, attester2hoster, performance_attester, storage_attester
		// performance_attester might also be hoster (or encoder) for same feed

		// performance attester calls done task multiple times for same performance challenge
		// first time we remove the task, so we need to check if tasks[stringtopic] in all the future calls to avoid err

		/*if (tasks[stringtopic]) */remove_from_roles({ tasks, role, stringtopic, log })

		remove_from_target_tasks({ targets, stringtopic, remotestringkey, log }) // we have always only one task per stringtopic for targets
		const target_tasks = get_target_tasks({ targets, remotestringkey, log })
		if (!target_tasks.length) {
			log({ type: 'cleanup', data: { text: 'remove from targets', role, remotestringkey, stringtopic  }})
			remove_from_targets({ targets, remotestringkey, log })
			// remove_from_registry({ sockets, stringtopic, remotestringkey, log })
		}

		swarm.leavePeer(b4a.from(remotestringkey, 'hex')) // stop attempting direct connections to the peer
		
		if (role === 'performance_attester') {
			remove_from_task_connections({ tasks, stringtopic, remotestringkey, log })
			// TODO: leavePeer from topic, even if there still is a task for other stuff (like hoster role etc.)
			const topic_tasks = get_tasks_count_for_topic({ tasks, stringtopic, log })
			const field = `${stringtopic}-${remotestringkey}`
			close_feeds({ feeds, field, log })
			if (!topic_tasks) {
				remove_from_tasks({ tasks, stringtopic, log })
			}
		} else {
			remove_from_tasks({ tasks, stringtopic, log })
			close_feeds({ feeds, field: stringtopic, log })
		}

		// SOCKETS
		decrease_socket_count({ sockets, remotestringkey, log })
		const connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
		if (!connections_for_socket) {
			close_streams_and_channels({ sockets, remotestringkey, log })
			remove_from_sockets({ sockets, remotestringkey, log })
		} 
	}
	// --------- NO TARGET/GENERAL SWARM -------------
	else { 
		// roles: encoder, hoster or sponsor to author/anyone in general swarm
		await clean_general_task({ state, role, stringtopic, peers, log })
	}

	// set back to in progress if there is another same-topic task with this peer
	if (tasks[stringtopic]?.connections[remotestringkey]) {
		set_status_for_connection({ status: 'in progress', tasks, stringtopic, remotestringkey})
	}
	// other peer didn't get a socket onclose, so they need to know task is done && needs to be cleaned
	if (sockets[remotestringkey]) { 
		notify_to_close_task({ state, remotestringkey, stringtopic, is_target_task, role, log })
	}

  log({ type: 'on close', data: { 
    text: `cleanup finished`, 
		role, 
		stringtopic,
		remotestringkey,
		conn_for_topic: tasks[stringtopic] ? Object.keys(tasks[stringtopic].connections) : undefined, 
		sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ]),
		roles: get_tasks({ tasks, log }).map(stringtopic => JSON.stringify(tasks[stringtopic].roles)),
		tasks: Object.keys(tasks) 
  } }) 
}

// HELPERS

async function clean_general_task ({ state, role, stringtopic, peers, log }) {
	const { sockets, feeds, tasks, swarm } = state
	const topic = b4a.from(stringtopic, 'hex')
	var connections_for_socket
	
	remove_from_roles({ tasks, role, stringtopic, log })
	
	// encoder & hoster2author might call done-task-cleanup multiple times
	for (const remotestringkey of peers) {
    if (tasks[stringtopic].connections[remotestringkey] === 'in cleanup') return
    set_status_for_connection({ status: 'in cleanup', tasks, stringtopic, remotestringkey})
			// same-topic tasks can be handled alongside another same-topic task
			// which means socket hasn't been incremented twice and when that task has been cleaned
			// sockets[remostringkeey] have been removed
			if (sockets[remotestringkey]) {
				decrease_socket_count({ sockets, remotestringkey, log })
				connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
				if (!connections_for_socket) {
					close_streams_and_channels({ sockets, remotestringkey, log })
					// same-topic tasks can be handled alongside another same-topic task
					// which means socket hasn't been incremented twice and when that task has been cleaned
					// sockets[remostringkeey] have been removed
					if (sockets[remotestringkey]) remove_from_sockets({ sockets, remotestringkey, log })
				}
			}
			if (tasks[stringtopic].connections[remotestringkey]) {
        remove_from_task_connections({ tasks, stringtopic, remotestringkey, log })
			}
	}
	
	const topic_tasks = get_tasks_count_for_topic({ tasks, stringtopic, log })
	if (!topic_tasks) {
		remove_from_tasks({ tasks, stringtopic, log })
		close_feeds({ feeds, field: stringtopic, log })
		swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
	} else {
		await try_refresh_discovery({ swarm, topic, tasks: tasks[stringtopic].roles, log }) 
	}
}

// STRINGTOPIC NEEDED
function remove_from_roles ({ tasks, role, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', role, stringtopic }})
	// hoster2author task was already done but while hoster was in hosting setup phase and their role was still hoster2author
	// some peers (i.e. encoders) replicated from them and are only closing their task now (hoster2author is client and peer)
	if (role === 'hoster2author' && !tasks[stringtopic].roles['hoster2author'].count) return 
	// author and hoster need to always be 'on'
	if (role === 'author' || role === 'hoster') return tasks[stringtopic].roles[role].count = 1
	tasks[stringtopic].roles[`${role}`].count--
	// if (tasks[stringtopic].roles[`${role}`].count === 0) {
	// 	delete tasks[stringtopic].roles[`${role}`].count
	// }
	// after `hoster2author` task is done, hoster gets a `hoster` role
	if (role === 'hoster2author') {
		if (tasks[stringtopic].roles['hoster']?.count) {
		 tasks[stringtopic].roles['hoster'].count++ 
	 } else {
		 tasks[stringtopic].roles['hoster'] = { count: 1, done: tasks[stringtopic].roles['hoster2author'].done }
	 }
	}
}
function get_tasks_count_for_topic ({ tasks, stringtopic, log }) {
	var count = 0
	Object.keys(tasks[stringtopic].roles).forEach(role => {
		count += tasks[stringtopic].roles[role].count
	})
	const rr = get_tasks({ tasks, log }).map(stringtopic => JSON.stringify(tasks[stringtopic].roles))
	log({ type: 'get_tasks_count_for_topic', data: { text: 'count_for_topic', stringtopic, count, roles: rr }})
	return count
}
function close_feeds ({ feeds, field, log }) {
	const feedkeys = Object.keys(feeds[field])
	feedkeys.forEach(async key => {
		const { feed } = feeds[field][key]
		remove_from_feeds({ feeds, field, log })
		await feed.core.close()
	})
}
function get_tasks ({ tasks, log }) {
	return Object.keys(tasks)
}
function get_sockets ({ sockets, log }) {
	return Object.keys(sockets)
}
function remove_from_tasks ({ tasks, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', stringtopic }})
	delete tasks[stringtopic]
}
function get_connections ({ tasks, stringtopic, log }) {
	var connections = !tasks[stringtopic] ? [] : Object.keys(tasks[stringtopic].connections)
	return connections
}
function remove_from_feeds ({ feeds, field, log }) {
	if (!feeds[field]) return log({ type: 'cleanup', data: { text: 'error: no matching feeds', field }})
	delete feeds[field]
}

// REMOTESTRINGKEY NEEDED
function decrease_socket_count ({ sockets, remotestringkey, log }) { 
	sockets[remotestringkey].count-- 
}
function remove_from_targets ({ targets, remotestringkey, log }) {
	if (!targets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching target', remotestringkey }})
	delete targets[remotestringkey]
}
function get_socket_count ({ sockets, remotestringkey, log }) {
	return sockets[remotestringkey].count
}
function remove_from_sockets ({ sockets, remotestringkey, log }) {
	if (!sockets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching socket', remotestringkey }})
	delete sockets[remotestringkey]
}
function close_streams_and_channels ({ sockets, remotestringkey, log }) {
	const { socket, replicationStream, channel, mux } = sockets[remotestringkey]
	if (channel) channel.close()
	mux.unpair({ protocol: 'datdot/alpha' })
	mux.destroy()
	socket.destroy()
	replicationStream.destroy()	
}
function get_target_tasks ({ targets, remotestringkey, log }) {
	return Object.keys(targets[remotestringkey].tasks)
}

// STRINGTOPIC && REMOTESTRINGKEY NEEDED
function remove_from_target_tasks ({ targets, stringtopic, remotestringkey, log }) {
	const target_tasks = targets[remotestringkey].tasks
	if (!target_tasks) return log({ type: 'cleanup', data: { text: 'error: no target tasks', stringtopic, remotestringkey }})
	delete targets[remotestringkey].tasks[stringtopic] // there is only one task
}
function remove_from_task_connections ({ tasks, stringtopic, remotestringkey, log }) {
	if (!tasks[stringtopic].connections[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no connection', stringtopic, remotestringkey }})
	log({ type: 'cleanup', data: { type: `Remove from task connections`, remotestringkey, stringtopic } })
	delete tasks[stringtopic].connections[remotestringkey]
}
function remove_from_registry ({ sockets, stringtopic, remotestringkey, log }) {
	const msgs = sockets[remotestringkey].channel.messages
	for (const msg_type of msgs) {
		msg_type.registry.delete(stringtopic)
	}
}
function notify_to_close_task ({ state, remotestringkey, stringtopic, is_target_task, role, log }) {
	const channel = state.sockets[remotestringkey].channel
	const [string_msg] = channel.messages
	log({ type: 'cleanup', data: { text: 'sending msg done', role, remotestringkey, stringtopic, is_target_task }})
	if (is_target_task && role !== 'performance_attester') string_msg.send(JSON.stringify({ type: 'done', stringtopic }))
	else {
		var remote_role // author or hoster or hoster2author
		if (role === 'encoder') remote_role = 'author/hoster2author'
		else if (role === 'hoster') remote_role = 'author/hoster2author/hoster'
		else if (role === 'sponsor') remote_role = 'author'
		else if (role === 'performance_attester') remote_role = 'hoster'
		string_msg.send(JSON.stringify({ type: 'done', role: remote_role, stringtopic }))
	}
}
function set_status_for_connection ({ status, tasks, stringtopic, remotestringkey}) {
	tasks[stringtopic].connections[remotestringkey] = status
}