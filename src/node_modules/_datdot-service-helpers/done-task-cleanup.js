const try_refresh_discovery = require('./try-refresh-discovery')
const b4a = require('b4a')

module.exports = {
	done_task_cleanup,
	remove_from_roles,
	get_tasks_count_for_topic,
	close_feeds,
	remove_from_tasks,
	get_connections,
	remove_from_feeds,
	decrease_socket_count,
	remove_from_targets,
	get_socket_count,
	remove_from_sockets,
	close_streams_and_channels,
	get_target_tasks,
	remove_from_target_tasks,
	remove_from_task_connections,
	remove_from_registry,
	get_tasks,
	get_sockets
}

async function done_task_cleanup ({ role, topic, remotestringkey, state, log }) { // TODO: add remotestringkey when known
	const { swarm, sockets, feeds, targets, tasks } = state
	const stringtopic = topic.toString('hex')
	log({ type: 'cleanup', data: { text: 'task done', role, stringtopic,remotestringkey } })

	// --------- TARGET -------------
	if (remotestringkey) {
		// TARGETS
		// stringtopic is one time used & is unique BUT
		// for performance-attesting we connect to many targets on same general topic
    // roles: attester2encoder, hoster2attester, performance_attester
		// performance_attester might also be hoster (or encoder) for same feed

		remove_from_roles({ tasks, role, stringtopic, log })

		// per peer there is only one stringtopic task in one moment
		remove_from_target_tasks({ targets, stringtopic, remotestringkey, log }) // we have always only one task per stringtopic for targets
		const target_tasks = get_target_tasks({ targets, remotestringkey, log })
		if (!target_tasks.length) {
			remove_from_targets({ targets, remotestringkey, log })
			remove_from_registry({ sockets, stringtopic, remotestringkey, log })
		}
		// so, close feeds and remove from tasks only if they are only perf attesters
		if (!get_tasks_count_for_topic) {
			// FEEDS
			close_feeds({ feeds, stringtopic, log })
			// TASKS
			remove_from_tasks({ tasks, stringtopic, log })
		}
		//SWARM
		swarm.leavePeer(b4a.from(remotestringkey, 'hex')) // stop attempting direct connections to the peer
		// SOCKETS
		decrease_socket_count({ sockets, remotestringkey, log })
		const connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
		if (!connections_for_socket) {
			close_streams_and_channels({ sockets, remotestringkey, log })
			remove_from_sockets({ sockets, remotestringkey, log })
		}
	}
	// --------- NO TARGET/GENERAL SWARM -------------
	// roles: encoder, hoster or sponsor to author/anyone in general swarm
	else {
		// TASKS
		console.log({ 
			roleee1: role,
			name: log.path, 
			conn: Object.keys(tasks[stringtopic].connections), 
			sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ])
		})
		const connections = get_connections({ tasks, stringtopic, log }) // define it here, before deleting tasks
		remove_from_roles({ tasks, role, stringtopic, log })
		
		for (const key of connections) { 
			decrease_socket_count({ sockets, remotestringkey: key, log })
			const connections_for_socket = get_socket_count({ sockets, remotestringkey: key, log })
			if (!connections_for_socket) {
				close_streams_and_channels({ sockets, remotestringkey: key, log })
				remove_from_task_connections({ tasks, stringtopic, remotestringkey: key, log })
				remove_from_sockets({ sockets, remotestringkey: key, log })
			}
		}
		const topic_tasks = get_tasks_count_for_topic({ tasks, stringtopic, log })
		if (!topic_tasks) {
			remove_from_tasks({ tasks, stringtopic, log })
			close_feeds({ feeds, stringtopic, log })
			swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
		} 
		else await try_refresh_discovery({ swarm, topic, tasks: tasks[stringtopic].roles, log }) 
	}
  log({ type: 'on close', data: { 
    text: `cleanup finished`, 
    remotestringkey,
    all_topics: get_tasks({ tasks, log }),
    conn: Object.keys(tasks).map(stringtopic => Object.keys(tasks[stringtopic].connections)), 
    sockets: Object.keys(sockets).map(key => [ key, sockets[key].count ])
  } }) 
}

// HELPERS

// STRINGTOPIC NEEDED
function remove_from_roles ({ tasks, role, stringtopic, log }) {
	const task = tasks[stringtopic]
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', role, stringtopic }})
	// author and hoster need to always be 'on'
	if (role === 'author' || role === 'hoster') return task.roles[role] = 1
	task.roles[`${role}`]--
	// after `hoster2author` task is done, hoster gets a `hoster` role
	if (role === 'hoster2author') task.roles['hoster'] ? task.roles['hoster']++ : task.roles['hoster'] = 1
}
function get_tasks_count_for_topic ({ tasks, stringtopic, log }) {
	var count = 0
	Object.keys(tasks[stringtopic].roles).forEach(role => {
		count += tasks[stringtopic].roles[role]
	})
	return count
}
function close_feeds ({ feeds, stringtopic, log }) {
	const feedkeys = Object.keys(feeds[stringtopic])
	feedkeys.forEach(async key => {
		const { feed } = feeds[stringtopic][key]
		remove_from_feeds({ feeds, stringtopic, log })
		await feed.core.close()
	})
}
function get_tasks ({ tasks, log }) {
	return Object.keys(tasks)
}
function get_sockets ({ sockets, log }) {
	return Object.keys(sockets)
}
function remove_from_tasks ({ tasks, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', stringtopic }})
	delete tasks[stringtopic]
}
function get_connections ({ tasks, stringtopic, log }) {
	var connections = !tasks[stringtopic] ? [] : Object.keys(tasks[stringtopic].connections)
	return connections
}
function remove_from_feeds ({ feeds, stringtopic, log }) {
	if (!feeds[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching feeds', stringtopic, stringtopic }})
	delete feeds[stringtopic]
}

// REMOTESTRINGKEY NEEDED
function decrease_socket_count ({ sockets, remotestringkey, log }) { 
	sockets[remotestringkey].count-- 
}
function remove_from_targets ({ targets, remotestringkey, log }) {
	if (!targets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching target', remotestringkey }})
	delete targets[remotestringkey]
}
function get_socket_count ({ sockets, remotestringkey, log }) {
	return sockets[remotestringkey].count
}
function remove_from_sockets ({ sockets, remotestringkey, log }) {
	if (!sockets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching socket', remotestringkey }})
	delete sockets[remotestringkey]
}
function close_streams_and_channels ({ sockets, remotestringkey, log }) {
	const { socket, replicationStream, channel, mux } = sockets[remotestringkey]
	if (channel) channel.close()
	mux.unpair({ protocol: 'datdot/alpha' })
	mux.destroy()
	socket.destroy()
	replicationStream.destroy()	
}
function get_target_tasks ({ targets, remotestringkey, log }) {
	return Object.keys(targets[remotestringkey].tasks)
}

// STRINGTOPIC && REMOTESTRINGKEY NEEDED
function remove_from_target_tasks ({ targets, stringtopic, remotestringkey, log }) {
	const target_tasks = targets[remotestringkey].tasks
	if (!target_tasks) return log({ type: 'cleanup', data: { text: 'error: no target tasks', stringtopic, remotestringkey }})
	delete targets[remotestringkey].tasks[stringtopic] // there is only one task
}
function remove_from_task_connections ({ tasks, stringtopic, remotestringkey, log }) {
	const connections = tasks[stringtopic].connections
	if (!connections) return log({ type: 'cleanup', data: { text: 'error: no connections', stringtopic, remotestringkey }})
	delete tasks[stringtopic].connections[remotestringkey]
}
function remove_from_registry ({ sockets, stringtopic, remotestringkey, log }) {
	const msgs = sockets[remotestringkey].channel.messages
	for (const msg_type of msgs) {
		msg_type.registry.delete(stringtopic)
	}
}