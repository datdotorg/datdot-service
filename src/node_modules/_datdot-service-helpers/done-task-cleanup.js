module.exports = {
	done_task_cleanup,
	remove_from_roles,
	get_tasks_for_roles,
	close_feeds,
	remove_from_tasks,
	get_connections,
	remove_from_feeds,
	decrease_socket_count,
	remove_from_targets,
	get_socket_count,
	remove_from_sockets,
	close_streams_and_channels,
	get_peer_tasks,
	remove_from_target_tasks,
	remove_from_task_connections,
	remove_from_registry,
	get_tasks
}

async function done_task_cleanup ({ role, topic, cache, log }) { // TODO: add remotestringkey when known
	const { swarm, sockets, feeds, targets, tasks } = cache
	const stringtopic = topic.toString('hex')
	log({ type: 'cleanup', data: { text: 'task done', role, stringtopic } })

	remove_from_roles({ tasks, role, stringtopic, log })

	const connections_for_task = get_connections({ tasks, stringtopic, log })
	for (const remotestringkey of connections_for_task) {
		decrease_socket_count({ sockets, remotestringkey, log })
		if (targets[remotestringkey]) {
			remove_from_target_tasks({ targets, stringtopic, remotestringkey, log }) // we have always only one task per stringtopic
			const peer_tasks = get_peer_tasks({ targets, remotestringkey, log })
			if (!peer_tasks.length) {
				remove_from_targets({ targets, remotestringkey, log })
				remove_from_registry({ sockets, stringtopic, remotestringkey, log })
			}
		}
		const connections_for_socket = get_socket_count({ sockets, remotestringkey, log })
		if (!connections_for_socket && !targets[remotestringkey]) {
			close_streams_and_channels({ sockets, remotestringkey, log })
			remove_from_task_connections({ tasks, stringtopic, remotestringkey, log })
			remove_from_sockets({ sockets, remotestringkey, log })
		}
	} 

	const topic_tasks = get_tasks_for_roles({ tasks, stringtopic, log })
	if (!topic_tasks) {
		swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
		close_feeds({ feeds, stringtopic, log })
		remove_from_tasks({ tasks, stringtopic, log })
	}
}



// HELPERS

// STRINGTOPIC NEEDED
function remove_from_roles ({ tasks, role, stringtopic, log }) {
	const task = tasks[stringtopic]
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', role, stringtopic }})
	task.roles[`${role}`]--
	// after `hoster2author` task is done, hoster gets a `hoster2peers` role
	if (role === 'hoster2author') task.roles['hoster2peers'] ? task.roles['hoster2peers']++ : task.roles['hoster2peers'] = 1
}
function get_tasks_for_roles ({ tasks, stringtopic, log }) {
	var count = 0
	Object.keys(tasks[stringtopic].roles).forEach(role => {
		count += tasks[stringtopic].roles[role]
	})
	return count
}
function close_feeds ({ feeds, stringtopic, log }) {
	const feedkeys = Object.keys(feeds[stringtopic])
	feedkeys.forEach(async key => {
		const { feed } = feeds[stringtopic][key]
		await feed.core.close()
		remove_from_feeds({ feeds, stringtopic, log })
	})
}
function get_tasks ({ tasks, log }) {
	return Object.keys(tasks)
}
function remove_from_tasks ({ tasks, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching task', stringtopic }})
	delete tasks[stringtopic]
}
function get_connections ({ tasks, stringtopic, log }) {
	if (!tasks[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no task so no connections', stringtopic }})
	return Object.keys(tasks[stringtopic].connections)
}
function remove_from_feeds ({ feeds, stringtopic, log }) {
	if (!feeds[stringtopic]) return log({ type: 'cleanup', data: { text: 'error: no matching feeds', stringtopic, stringtopic }})
	delete feeds[stringtopic]
}

// REMOTESTRINGKEY NEEDED
function decrease_socket_count ({ sockets, remotestringkey, log }) { sockets[remotestringkey].count-- }
function remove_from_targets ({ targets, remotestringkey, log }) {
	if (!targets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching target', remotestringkey }})
	delete targets[remotestringkey]
}
function get_socket_count ({ sockets, remotestringkey, log }) {
	return sockets[remotestringkey].count
}
function remove_from_sockets ({ sockets, remotestringkey, log }) {
	if (!sockets[remotestringkey]) return log({ type: 'cleanup', data: { text: 'error: no matching socket', remotestringkey }})
	delete sockets[remotestringkey]
}
function close_streams_and_channels ({ sockets, remotestringkey, log }) {
	const { socket, replicationStream, channel, mux } = sockets[remotestringkey]
	if (channel) channel.close()
	mux.unpair({ protocol: 'datdot/alpha' })
	mux.destroy()
	socket.destroy()
	replicationStream.destroy()	
}
function get_peer_tasks ({ targets, remotestringkey, log }) {
	return Object.keys(targets[remotestringkey].tasks)
}

// STRINGTOPIC && REMOTESTRINGKEY NEEDED
function remove_from_target_tasks ({ targets, stringtopic, remotestringkey, log }) {
	const target_tasks = targets[remotestringkey].tasks
	if (!target_tasks) return log({ type: 'cleanup', data: { text: 'error: no target tasks', stringtopic, remotestringkey }})
	delete target_tasks[stringtopic] // there is only one task
}
function remove_from_task_connections ({ tasks, stringtopic, remotestringkey, log }) {
	const connections = tasks[stringtopic].connections
	if (!connections) return log({ type: 'cleanup', data: { text: 'error: no connections', stringtopic, remotestringkey }})
	delete tasks[stringtopic].connections[remotestringkey]
}
function remove_from_registry ({ sockets, stringtopic, remotestringkey, log }) {
	const msgs = sockets[remotestringkey].channel.messages
	for (const msg_type of msgs) {
		msg_type.registry.delete(stringtopic)
	}
}