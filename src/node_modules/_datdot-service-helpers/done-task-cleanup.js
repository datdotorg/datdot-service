const update_swarm_discovery = require('./update-swarm-discovery')

module.exports = done_task_cleanup

async function done_task_cleanup ({ role, topic, cache, log }) {
	// NOTE: the initiator calls this
	return new Promise(async (resolve, reject) => {
		const { swarm, sockets, feeds, peers, tasks } = cache
		const stringtopic = topic.toString('hex')
		log({ type: 'task', data: { text: 'Removing task from cache', role, topic: topic.toString('hex') }})
		
		const { 
			author, // { server: true }
			sponsor, // { client: true } 
			encoder2author, // { client: true }
			encoder2attestor, // { server: true }
			attestor2encoder, // { client: true }
			attestor2hoster, // { server: true }
			hoster2author, // { server: true, client: true }
			hoster2attestor, // { client: true }
			hoster2peers, // { server: true }
			perf_attestor 
		} = tasks[stringtopic] 
		
		
		try {
			if (role === 'hoster2author') {
				tasks[stringtopic]['hoster2peers'] ? tasks[stringtopic]['hoster2peers']++ : tasks[stringtopic]['hoster2peers'] = 1
			}
			tasks[stringtopic].roles[`${role}`]--
			
			// get all active connections (remotestringkeys) for this topic
			const connections = Object.keys(tasks[stringtopic].connections)

			// check for each remotestringkey if there are jobs (count) left for that key
			const conn_len = connections.length
			for (var i = 0; i < conn_len; i++) {
				const remotestringkey = connections[i]
				log({ type: 'task', data: { text: 'socket', remotestringkey }})
				const { socket, count, replicationStream, channel, mux } = sockets[remotestringkey]
				sockets[remotestringkey].count--
				if (sockets[remotestringkey].count === 0) {
					log({ type: 'task', data: { text: 'No more count for this socket', remotestringkey }})
					// if job count for this remotestringkey is 0, close/end stuff
					socket ? socket.end() : log({ type: 'task', data: { text: 'Error: no socket' }})
					channel ? channel.close() : log({ type: 'task', data: { text: 'No channel to close' }})
					replicationStream ? replicationStream.end() : log({ type: 'task', data: { text: 'Error: no replicationStream' }})
					// and delete the connection and the socket from cache 
					delete tasks[stringtopic].connections[remotestringkey]
					delete cache.sockets[remotestringkey]
				}
			}

			// if no more task for any of the roles, delete tasks[stringtopic]
			var all_tasks_count = 0
			const all_tasks = Object.keys(tasks[stringtopic].roles).map(role => {
				all_tasks_count += tasks[stringtopic].roles[role]
				return [ role, tasks[stringtopic].roles[role]] 
			})
			log({ type: 'task', data: { 
				text: 'Done task cleanup', 
				connections_for_topic: Object.keys(tasks[stringtopic].connections), 
				connections_for_topic_len: Object.keys(tasks[stringtopic].connections).length, 
				stringtopic, 
				all_sockets: Object.keys(sockets), 
				all_tasks_count_for_topic: all_tasks_count, 
				all_tasks: JSON.stringify(all_tasks),
				role  
			}})

			// if no tasks, leave topic and close feeds
			if (all_tasks_count === 0) { 
				log({ type: 'replicate feeds', data: { text: 'leaving topic, no active tasks', stringtopic } })
				swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
				
				const feedkeys = Object.keys(feeds[stringtopic])
				feedkeys.forEach(async key => {
					const {feed} = feeds[stringtopic][key]
					await feed.core.close()
				})

				delete tasks[stringtopic]
				
				return resolve()
			}

			const mode = await update_swarm_discovery({ swarm, topic, tasks: tasks[stringtopic].roles, log })
			resolve()
		} catch(err) {
			log({ type: 'task', data: { text: 'Error: in done task cleanup', stringtopic, err }})
			reject()
		}  
	})
}