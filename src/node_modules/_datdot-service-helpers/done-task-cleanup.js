const update_swarm_discovery = require('./update-swarm-discovery')

module.exports = done_task_cleanup

async function done_task_cleanup ({ role, topic, cache, log }) {
	// NOTE: the initiator calls this
	return new Promise(async (resolve, reject) => {
		const { swarm, topics, sockets, feeds, peers } = cache
		const stringtopic = topic.toString('hex')
		log({ type: 'task', data: { text: 'Removing task from cache', count: topics[stringtopic].tasks }})
		
		const { 
			author, // { server: true }
			sponsor, // { client: true } 
			encoder2author, // { client: true }
			encoder2attestor, // { server: true }
			attestor2encoder, // { client: true }
			attestor2hoster, // { server: true }
			hoster2author, // { server: true, client: true }
			hoster2attestor, // { client: true }
			hoster2peers, // { server: true }
			perf_attestor 
		} = topics[stringtopic].tasks 
		
		
		try {
			if (role === 'hoster2author') {
				topics[stringtopic].tasks['hoster2peers'] ? topics[stringtopic].tasks['hoster2peers']++ : topics[stringtopic].tasks['hoster2peers'] = 1
			}
			topics[stringtopic].tasks[`${role}`]--
			const task_roles = Object.keys(topics[stringtopic].tasks)
			const active_tasks = task_roles.filter(role => topics[stringtopic].tasks[`${role}`] )
			log({ type: 'task', data: { text: 'Active tasks', tasks:topics[stringtopic].tasks, active_tasks }})
			
			const remotekeys = Object.keys(topics[stringtopic].sockets)
			remotekeys.forEach(async key => {
				console.log({name: log.path, sockettt: sockets[key] ? true: false, remotekeys, sockets})
				const { socket, count, replicationStream, channel } = sockets[key]
				sockets[key].count--
				log({ type: 'task', data: { text: 'Sockets count', count: sockets[key].count, remotekeys  }})
				if (!sockets[key].count) {
					socket ? socket.end() : log({ type: 'task', data: { text: 'Error: no socket' }})
					channel ? channel.close() : log({ type: 'task', data: { text: 'No channel to close' }})
					replicationStream ? replicationStream.end() : log({ type: 'task', data: { text: 'Error: no replicationStream' }})
					
					delete cache.sockets[key]
					delete topics[stringtopic].sockets[key]
				}
			})

			if (!active_tasks.length) {
				log({ type: 'replicate feeds', data: { text: 'leaving topic, no active tasks', stringtopic } })
				swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
				
				const feedkeys = Object.keys(feeds[stringtopic])
				feedkeys.forEach(async key => {
					const {feed} = feeds[stringtopic][key]
					await feed.core.close()
				})

				delete topics[stringtopic]
				
				return resolve()
			}

			const mode = await update_swarm_discovery({ swarm, topic, tasks: topics[stringtopic].tasks, log })
			resolve()
		} catch(err) {
			log({ type: 'task', data: { text: 'Error: in done task cleanup', stringtopic, err }})
			reject()
		}  
	})
}