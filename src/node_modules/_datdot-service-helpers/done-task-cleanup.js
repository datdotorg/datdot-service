const try_refresh_discovery = require('_datdot-service-helpers/try-refresh-discovery')

module.exports = done_task_cleanup

async function done_task_cleanup ({ role, topic, cache, log }) {
	return
	// NOTE: the initiator calls this
	return new Promise(async (resolve, reject) => {
		const { swarm, sockets, feeds, targets, tasks } = cache
		const stringtopic = topic.toString('hex')
		log({ type: 'cleanup', data: { text: 'cleanup', role, topic: topic.toString('hex') }})
		
		const { 
			author, // { server: true }
			sponsor, // { client: true } 
			encoder2author, // { client: true }
			encoder2attestor, // { server: true }
			attestor2encoder, // { client: true }
			attestor2hoster, // { server: true }
			hoster2author, // { server: true, client: true }
			hoster2attestor, // { client: true }
			hoster2peers, // { server: true }
			perf_attestor 
		} = tasks[stringtopic] 
		
		try {
			if (role === 'hoster2author') {
				tasks[stringtopic]['hoster2peers'] ? tasks[stringtopic]['hoster2peers']++ : tasks[stringtopic]['hoster2peers'] = 1
			}
			log({ type: 'cleanup', data: { text: 'before cleanup', stringtopic, role, task_count: tasks[stringtopic].roles[`${role}`] } })
			tasks[stringtopic].roles[`${role}`]--
			
			// get all active connections (remotestringkeys) for this topic
			const connections = Object.keys(tasks[stringtopic].connections)
			
			// all task for any of the roles, delete tasks[stringtopic]
			var open_tasks = 0
			Object.keys(tasks[stringtopic].roles).forEach(role => {
				open_tasks += tasks[stringtopic].roles[role]
			})
			
			// check for each remotestringkey if there are jobs (count) left for that key
			const conn_len = connections.length
			var remotestringkey
			
			for (var i = 0; i < conn_len; i++) {
				remotestringkey = connections[i]
				log({ type: 'cleanup', data: { 
					text: 'looping over open connections',
					role,
					remotestringkey, 
					sockets: Object.keys(sockets),
					socket_count_for_peer: sockets[remotestringkey].count,
					stringtopic,
					connections_for_topic: Object.keys(tasks[stringtopic].connections), 
					open_tasks
				}})

				// delete stuff related to target peers
				if (targets[remotestringkey]) {				
					delete targets[remotestringkey].topics[stringtopic]
					const peer_topics_len = Object.keys(targets[remotestringkey].topics).length
					if (!peer_topics_len) {
						log({ type: 'cleanup', data: { text: 'delete target', stringtopic, role, remotestringkey } })
						delete targets[remotestringkey]
						const string_msg = sockets[remotestringkey].channel.messages[0]
						string_msg.registry.delete(stringtopic)
					}
				}
				
				const { socket, count, replicationStream, channel, mux } = sockets[remotestringkey]
				sockets[remotestringkey].count--
				if (!sockets[remotestringkey].count && !targets[remotestringkey]) {
					log({ type: 'cleanup', data: { text: 'socket count 0', remotestringkey }})
					// if job count for this remotestringkey is 0, close/end stuff
					if (channel) channel.close()
					mux.unpair({ protocol: 'datdot/alpha' })
					mux.destroy()
					socket.destroy()
					replicationStream.destroy()
					// and delete the connection and the socket from cache 
					delete tasks[stringtopic].connections[remotestringkey]
					delete cache.sockets[remotestringkey]
				}
			}


			// if no tasks, leave topic and close feeds
			if (!open_tasks) { 
				log({ type: 'cleanup', data: { text: 'leaving topic, no active tasks', stringtopic } })
				swarm.leave(topic) // stop getting new connections on topic. leave will not close any existing connections.
				
				const feedkeys = Object.keys(feeds[stringtopic])
				feedkeys.forEach(async key => {
					const {feed} = feeds[stringtopic][key]
					await feed.core.close()
				})

				delete tasks[stringtopic]
				
				return resolve()
			}

			const mode = await try_refresh_discovery({ swarm, topic, tasks: tasks[stringtopic].roles, log })
			resolve()
		} catch(err) {
			log({ type: 'cleanup', data: { text: 'Error: in done task cleanup', stringtopic, err }})
			reject()
		}  
	})
}


// function close_stuff ({account, remotestringkey, log}) {
// 	// TODO: replace this with targeted feed.onclose, channel.onclose listeners and closing when that triggered
// 	const {cache} = account
// 	const { swarm, sockets, tasks, feeds } = cache

// 	// check if peer hasn't already closed their stuff in done-task-cleanup
// 	if (!sockets[remotestringkey]) return

// 	sockets[remotestringkey].count--

// 	log({ type: 'close stuff', data: { 
// 		text: 'close-stuff', 
// 		remotestringkey, 
// 		sockets: Object.keys(sockets),
// 		count: sockets[remotestringkey].count,
// 	}})
	
// 	// delete the connection
// 	const task_tasks = Object.keys(tasks)
// 	const task_tasks_len = task_tasks.len

// 	for (var i = 0; i < task_tasks_len; i++) {
// 		const stringtopic = task_tasks[i]
// 		const remotekeys = Object.keys(tasks[stringtopic].connections)

// 		// delete stuff related to target peers
// 		if (targets[remotestringkey]) {				
// 			delete targets[remotestringkey].tasks[stringtopic]
// 			const target_tasks_len = Object.keys(targets[remotestringkey].tasks).length
// 			if (!target_tasks_len) {
// 				delete targets[remotestringkey]
// 				const string_msg = sockets[remotestringkey].channel.messages[0]
// 				string_msg.registry.delete(stringtopic)
// 			}
// 		}
		
// 		var open_tasks = 0
// 		Object.keys(tasks[stringtopic].roles).forEach(role => { open_tasks += tasks[stringtopic].roles[role] })

// 		// if job count for this remotestringkey is 0, close/end stuff
// 		if (sockets[remotestringkey] && !sockets[remotestringkey].count && !targets[remotestringkey]) {
// 			const { socket, count, replicationStream, channel, mux } = sockets[remotestringkey]
// 			// log({ type: 'close-stuff', data: { text: 'No more count for this socket', remotestringkey, count: sockets[remotestringkey].count }})
// 			// mux.unpair({ protocol: 'datdot/alpha' })
// 			if (channel) channel.close()
// 			mux.unpair({ protocol: 'datdot/alpha' })
// 			mux.destroy()
// 			socket.destroy()
// 			replicationStream.destroy()
// 			// and delete the socket from cache 
// 			delete tasks[stringtopic].connections[remotestringkey]
// 			delete cache.sockets[remotestringkey]
// 		}
// 		remotekeys.forEach(key => { 
// 			if (key === remotestringkey) {
// 				delete tasks[stringtopic].connections[key]
// 				// delete tasks if no jobs 
// 				if (!open_tasks) { 
// 					// log({ type: 'close-stuff', data: { text: 'leaving topic, no active tasks', stringtopic } })
// 					swarm.leave(b4a.from(stringtopic, 'hex')) // stop getting new connections on topic. leave will not close any existing connections.
					
// 					const feedkeys = Object.keys(feeds[stringtopic])
// 					feedkeys.forEach(async key => {
// 						const {feed} = feeds[stringtopic][key]
// 						await feed.core.close()
// 					})
	
// 					delete tasks[stringtopic]
					
// 				}
// 			}
// 		})
// 	}
	
// }

