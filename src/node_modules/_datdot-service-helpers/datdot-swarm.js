const hyperswarm = require('hyperswarm')
const multiplex = require('multiplex')
const pump = require('pump')

/*

const store = {
  topics: {
    string_topic1: {
      discovery,
      tasks: { 
        task_id1: {  }, 
        task_id2: {  } 
      }, 
    }
  },

  tasks: {
    task_id1: { callback }, 
    task_id2: { callback } 
  },

  peers: {
    remotekey1: { 
      socket, 
      info, 
      plex,
      task_channels: {
        task_id: { subsocket }
      }
     }
  }
}
*/

const store = {
  topics: {},
  tasks: {},
  peers: {}
}
var swarm

module.exports = datdot_swarm

async function datdot_swarm () {
  swarm = new hyperswarm()

  swarm.on('connection', function on_new_connection (socket, info) {
    console.log({info})

    const topics = Object.keys(store.topics)
    
    for (var i = topics.length; i--;) {
      const string_topic = topics[i]
      // if (info.topics.includes(string_topic)) handle_peer_topic({ socket, info, string_topic }) // TODO: is topic buffer or string?
      handle_peer_topic({ socket, info, string_topic }) // TODO: is topic buffer or string?
    }
    
    info.on('topic', topic => {
      // TODO: check for when peers leave a topic too!
      console.log({ type: 'swarm', data: { text: 'New topic joined'}})
      const new_topic = topic.toString('hex')
      const topics = Object.keys(store.topics)
      for (var i = topics.lengh; i--;) {
        const string_topic = topics[i]
        if (new_topic === string_topic) handle_peer_topic({ socket, info, string_topic }) // TODO: is topic buffer or string?
      }
    })

  })
  
  const swarmAPI = { connect_topic, disconnect_topic }

  return swarmAPI
  // await vaultAPI.serviceDB.get('swarm', {topics...}) - store for reloading if process crashes

  function connect_topic (log, task_id, topic, mode, callback) {
    const string_topic = topic.toString('hex')
    console.log({ type: 'swarm', data: { Text: 'Connecting topic' } })
    const opts = { task_id, string_topic, topic, mode, callback, log }

    if (store.topics[string_topic]) handle_existing_topic(opts)
    else handle_new_topic(opts)
  }

  async function disconnect_topic (log, topic, task_id) {
    console.log({ type: 'swarm', data: { Text: 'Disconnecting topic' } })
    const string_topic = topic.toString('hex')

    if (!store.topics[string_topic] && !store.tasks[task_id]) return

    // close connections (subsockets)
    // const subsocket = store.tasks[task_id].subsocket
    // console.log({subsocket})
    // subsocket.close()

    // remove task from tasks and topics
    store.tasks[task_id] = undefined
    store.topics[string_topic].tasks[task_id] = undefined

    // leave topic and destroy discovery if no tasks left
    const counter = Object.keys(store.topics[string_topic].tasks).length
    console.log({ type: 'swarm', data: { Text: 'All channels for this topic', counter } })
    if (counter === 1) {
      swarm.leave(topic)
      await store.topics[string_topic].discovery.destroy()
      store.topics[string_topic] = undefined
    } 
  }

}


// HELPERS

async function handle_existing_topic (opts) {
  const { task_id, string_topic, callback, log } = opts
  if (store.tasks[task_id]) return
  console.log({ type: 'swarm', data: { text: 'Adding event to existing topic', task_id, string_topic }})
  // add task to existing topic
  store.topics[string_topic].tasks[task_id] = {}
  store.tasks[task_id] = { callback }
}

async function handle_new_topic (opts) {
  const { task_id, string_topic, topic, mode, callback, log } = opts
  const discovery = swarm.join(topic, mode)
  if (mode.server) await discovery.flushed()
  console.log({ type: 'swarm', data: { Text: 'Joining new topic' } })
  store.topics[string_topic] = { discovery, tasks: { [task_id]: {  } } }
  store.tasks[task_id] = { callback }
}

function handle_peer_topic ({ socket, info, string_topic, log }) {
    const remotekey = info.publicKey.toString('hex')
    const tasks_for_topic = Object.keys(store.topics[string_topic].tasks)
    for (var k = tasks_for_topic.length; k--;) {
      const task_id = tasks_for_topic[k]
      console.log({ type: 'swarm', data: { text: 'Task for topic', string_topic, task_id } })
      const callback = store.tasks[task_id].callback
      const connect_to_peer = callback(socket.remotePublicKey)
      console.log({ type: 'swarm', data: { should_connect: !!connect_to_peer } })
      if (!connect_to_peer) continue
      const plex = load_plex(remotekey, info, socket)
      console.log({ type: 'swarm', data: { plex: !!plex } })
      const channel_id = `${task_id}:${ sort_and_join(swarm.keyPair.publicKey.toString('hex'), remotekey) }`
      console.log({ type: 'swarm', data: { channel_id } })
      const subsocket = plex.createSharedStream(channel_id, { encoding: 'utf8' })

      subsocket.on('error', () => {
        console.log({ type: 'swarm', data: { text: 'Subsocket on error'}})
      })

      subsocket.isInitiator = info.client
      subsocket.remotePublicKey = socket.remotePublicKey
      store.tasks[task_id].subsocket = subsocket
      connect_to_peer(subsocket)
    }
  }

  function load_plex (remotekey, info, socket, log) {
    if (store.peers[remotekey]) return store.peers[remotekey].plex
    else {
      // const plex = multiplex(opts, function onStream (stream, id) {})
      const plex = multiplex()
      store.peers[remotekey] = { socket, info, plex}
      pump(socket, plex, socket, onError)
      return plex
    }
  }

  function sort_and_join (localkey, remotekey) { return  [localkey, remotekey].sort().join('') }
 
  function onError () {
    console.log({ type: 'error', data: { Text: 'Pump onError' } })
  } 
    

  // OLD


  // plex1.pipe(plex2)
  

  // stream1.write(new Buffer('stream one!'))
  // stream2.write(new Buffer('stream two!'))

  // multiplex.on('error', function (err) {})
  // // Emitted when the outer stream encounters invalid data

  // multiplex.on('stream', function (stream, id) {})
  // // Emitted when a it a new stream arrives.

  // stream.on('error', function (err) {})
  // // Emitted if the inner stream is destroyed with an error

  // swarm.on('connection', async (socket, info) => {
  //   const remotekey_string = info.publicKey.toString('hex')
  //   console.log({ type: 'swarm', data: { Text: 'New connection', remotekey_string } })
  //   // TODO: every socket comes from a swarm peer
  //   // => not every swarm peer is in the relevant topic
  //   // => filter for all peers which are in the relevant topic

  //   // callback(remotekey_string, )

  //   const plex = multiplex(opts, onStream)
  //   pump(socket, plex, socket, onError)

  //   const task_channels = {}
  //   topics[string_topic].peers[remotekey_string] = { socket, plex, info, task_channels }
  //   const tasks = topics[string_topic].tasks

  //   Object.keys(tasks).forEach(task_id => {
  //     const local = tasks[task_id]
  //     const { path, callback, peer_channels } = local
  //     // const channel_id = task_id
  //     const channel_id = `${task_id}:${ sort_and_join(keyPair.publicKey.toString('hex'), remotekey_string) }`
  //     console.log({ type: 'swarm', data: { Text: 'channel id', channel_id } })
  //     const subsocket = plex.createSharedStream(channel_id, opts)
  //       // const subsocket = plex.createStream(channel_id, opts)
  //       callback(subsocket, info)
  //       peer_channels[remotekey_string] = { subsocket }
  //       task_channels[task_id] = { path, subsocket }
  //     })
      
  //     // ----------------------------------------------------------------------
 
  //     socket.on('close', () => {
  //       console.log('-------CLOSE ----------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       topics[string_topic].peers[peerkey] = undefined 
  //     })
  //     socket.on('end', () => { 
  //       console.log('-------_END ----------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       topics[string_topic].peers[peerkey] = undefined 
  //     })
  //     // socket.on('error', () => {
  //     //   socket.destroy()
  //     //   topics[string_topic].peers[peerkey] = undefined
  //     // })
  //     function onStream(stream, id) {
  //       // onStream will be called with (sub_socket, id) whenever
  //       // a new remote sub-socket is created with an id that hasn't
  //       // already been created locally with plex.createStream()
  //       stream.on('data', function(c) {
  //         console.log('data', id, c.toString())
  //       })
  //     }
  //   })


  // function handle_peer ({ socket, info, string_topic }) {
  //   const { publicKey } = info
  //   const remotekey = publicKey.toString('hex')
    
  //   const task_ids = Object.keys(store.tasks)
  //   for (var i = topics.lengh; i--;) {
  //     const task_id = task_ids[i]
  //     const { topic, callback } = store.tasks[task_id]
  //     const task_topic = topic.toString('hex')
  //     if (string_topic === task_topic) {
  //       const onconnection = callback(remotekey)
  //       if (onconnection) onconnection(plexstream)
  //     }
  //   }


  //   // new connection => check if peer exists 
  //   if (!store.peers[remotekey]) {
  //     store.peers[remotekey] = {
  //       socket, 
  //       info, 
  //       task_channels: {}
  //     }
  //   }

  // }

  /*
  
---------------------------------

// TODO: persist info to users serviceDB to restore connection states on process reboot
const store = {
  topics: {
    string_topic1: {
      discovery,
      task_channels: {
        task_id1: subsocket,
        task_id2: subsocket,
        task_id3: subsocket,
      },
    },
  },
  tasks: {
    task_id1: {
      path, // for debugging purposes
      topic,
      callback,
      subsocket
    },
  },
  peers: {
    remotekey1: {
      socket, // keeping track to close them later
      plex, // to create subsockets + keeping track to close them later
      info, // to listen to joining/leaving topics
    },
  }
}

const topics = {
  string_topic1: {
    discovery,
    tasks: {
      task_id1: {
        path, // for debugging purposes
        onconnection,
        peer_channels: { // keeping track to close them later
          remotekey1: subsocket,
          remotekey2: subsocket
        }
      }
      task_id2: {},
      task_id3: {},
    }, 
    peers: {
      remotekey1: {
        socket, // keeping track to close them later
        plex, // to create subsockets + keeping track to close them later
        info, // to listen to joining/leaving topics
        task_channels: {
          task_id1: subsocket,
          task_id2: subsocket,
          task_id3: subsocket,
        }
      },
      remotekey2: {},
      remotekey3: {},
    }
  },
  string_topic2: { },
  string_topic3: { },
}
*/