const hyperswarm = require('hyperswarm')
const multiplex = require('multiplex')
const pump = require('pump')

/*

const store = {
  topics: {
    string_topic1: {
      discovery, 
      tasks: { 
        task_id1: {  }, 
        task_id2: {  } 
      }, 
    }
  },

  tasks: {
    task_id1: { callback }, 
    task_id2: { callback } 
  },

  peers: {
    remote_key1: {
      socket,
      info,
      plex,
      task_channels: {
        task_id1: subsocket,
        task_id2: subsocket,
        task_id3: subsocket,
      }
    }
  }
}
*/

const store = {
  topics: {},
  tasks: {},
  peers: {}
}
var swarm

module.exports = datdot_swarm

async function datdot_swarm (vaultAPI, log) {
  const keyPair = { publicKey: await vaultAPI.noisePublicKey, secretKey: await vaultAPI.noisePrivateKey }
  swarm = new hyperswarm({ keyPair, announceLocalAddress: true })

  swarm.on('connection', function on_new_connection (socket, info) {
    log({ type: 'swarm', data: { text: 'New connection'}})
    // console.log({info, socket})
    // console.log('publicKeys', socket.publicKey === info.publicKey)
    // console.log({socket: socket.publicKey, info: info.publicKey})
    const topics = Object.keys(store.topics)
    
    for (var i = topics.length; i--;) {
      const string_topic = topics[i]
      // if (info.topics.includes(string_topic)) handle_peer_topic({ socket, info, string_topic, log }) // TODO: is topic buffer or string?
      handle_peer_topic({ socket, info, string_topic, log }) // TODO: is topic buffer or string?
    }
    
    info.on('topic', topic => {
      // TODO: check for when peers leave a topic too!
      log({ type: 'swarm', data: { text: 'New topic joined'}})
      const new_topic = topic.toString('hex')
      const topics = Object.keys(store.topics)
      for (var i = topics.lengh; i--;) {
        const string_topic = topics[i]
        if (new_topic === string_topic) handle_peer_topic({ socket, info, string_topic, log }) // TODO: is topic buffer or string?
      }
    })

  })

  log({ type: 'swarm', data: { text: 'New swarm instance'}})
  
  const swarmAPI = { connect_topic, disconnect_topic }

  return swarmAPI
  // await vaultAPI.serviceDB.get('swarm', {topics...}) - store for reloading if process crashes


  // this.info.on('topic', (topic) => this.emit('topic', topic))
  // check when a peer socket joins additional topics + figure out how to notice when they leave topics

  function connect_topic (log, task_id, topic, callback) {
    const string_topic = topic.toString('hex')
    log({ type: 'swarm', data: { text: 'New topic', string_topic, task_id } })
    const path = `${log.path}/${task_id}`
    const opts = { log, task_id, string_topic, topic, path, callback }

    if (store.topics[string_topic]) handle_existing_topic(opts)
    else handle_new_topic(opts)
  }

  async function disconnect_topic (opts) {
    // const { log, task_id, string_topic, topic, path, callback } = opts
    // log({ type: 'swarm', data: { Text: 'Disconnecting topic', name: log.path } })
    // const string_topic = topic.toString('hex')
    // const remotekey_string = remotekey.toString('hex')
    // // await topics[string_topic].discovery.destroy()

    // const tasks = store.topics[string_topic].tasks
    // const counter = Object.keys(store.topics[string_topic].tasks).length
    // log({ type: 'swarm', data: { Text: 'All channels for this topic', counter } })
    // if (counter === 1) {
    //   await topics[string_topic].discovery.destroy()
    //   topics[string_topic] = undefined
    // } else {
    //   topics[string_topic].peers[remotekey_string] = undefined
    //   topics[string_topic].tasks[task_id] = undefined
    // }
  }

}


// HELPERS

async function handle_existing_topic (opts) {
  const { log, task_id, string_topic, callback } = opts
  log({ type: 'swarm', data: { text: 'Adding event to existing topic', task_id}})
  
  store.topics[string_topic].tasks[task_id] = {}
  store.tasks[task_id] = { callback }

  // topics[string_topic].counter++
  // topics[string_topic].callbacks.push(callback)
  // const peers = Object.values(topics[string_topic].peers)
  // peers.forEach(peer => callback(peer.socket, peer.info))
}

async function handle_new_topic (opts) {
  const { log, task_id, string_topic, topic, callback } = opts
  const discovery = swarm.join(  topic, { server: true, client: true })
  log({ type: 'swarm', data: { Text: 'Joining topic' } })
  store.topics[string_topic] = { discovery, tasks: { [task_id]: {  } } }
  store.tasks[task_id] = { callback }
  console.log({store})
}

function handle_peer_topic ({ socket, info, string_topic, log }) {
    const remotekey = info.publicKey.toString('hex')
    const tasks_for_topic = Object.keys(store.topics[string_topic].tasks)
    for (var k = tasks_for_topic.length; k--;) {
      const task_id = tasks_for_topic[k]
      log({ type: 'swarm', data: { Text: 'Task for topic', string_topic, task_id } })
      const callback = store.tasks[task_id].callback
      const connect_to_peer = callback(info.publicKey)
      log({ type: 'swarm', data: { Text: 'Should connect to peer?', connect_to_peer } })
      if (!connect_to_peer) continue
      const plex = load_plex(remotekey, info, socket)
      log({ type: 'swarm', data: { Text: 'Plex', plex: plex === true } })
      const channel_id = `${task_id}:${ sort_and_join(swarm.keyPair.publicKey.toString('hex'), remotekey) }`
      log({ type: 'swarm', data: { Text: 'Channel id', channel: channel_id === true } })
      const subsocket = plex.createSharedStream(channel_id, {})
      subsocket.isInitiator = info.client
      store.peers[remotekey].task_channels = { [task_id]: subsocket }
      connect_to_peer(subsocket)
    }
  }

  function load_plex (remotekey, info, socket) {
    if (store.peers[remotekey]) return store.peers[remotekey].plex
    else {
      // const plex = multiplex(opts, function onStream (stream, id) {})
      const plex = multiplex()
      store.peers[remotekey] = { socket, info,  plex}
      pump(socket, plex, socket, onError)
      return plex
    }
  }

  function sort_and_join (localkey, remotekey) { return  [localkey, remotekey].sort().join('') }
 
  function onError () {
    log({ type: 'error', data: { Text: 'Pump onError' } })
  } 
    

  // OLD


  // plex1.pipe(plex2)
  

  // stream1.write(new Buffer('stream one!'))
  // stream2.write(new Buffer('stream two!'))

  // multiplex.on('error', function (err) {})
  // // Emitted when the outer stream encounters invalid data

  // multiplex.on('stream', function (stream, id) {})
  // // Emitted when a it a new stream arrives.

  // stream.on('error', function (err) {})
  // // Emitted if the inner stream is destroyed with an error

  // swarm.on('connection', async (socket, info) => {
  //   const remotekey_string = info.publicKey.toString('hex')
  //   log({ type: 'swarm', data: { Text: 'New connection', remotekey_string } })
  //   // TODO: every socket comes from a swarm peer
  //   // => not every swarm peer is in the relevant topic
  //   // => filter for all peers which are in the relevant topic

  //   // callback(remotekey_string, )

  //   const plex = multiplex(opts, onStream)
  //   pump(socket, plex, socket, onError)

  //   const task_channels = {}
  //   topics[string_topic].peers[remotekey_string] = { socket, plex, info, task_channels }
  //   const tasks = topics[string_topic].tasks

  //   Object.keys(tasks).forEach(task_id => {
  //     const local = tasks[task_id]
  //     const { path, callback, peer_channels } = local
  //     // const channel_id = task_id
  //     const channel_id = `${task_id}:${ sort_and_join(keyPair.publicKey.toString('hex'), remotekey_string) }`
  //     log({ type: 'swarm', data: { Text: 'channel id', channel_id } })
  //     const subsocket = plex.createSharedStream(channel_id, opts)
  //       // const subsocket = plex.createStream(channel_id, opts)
  //       callback(subsocket, info)
  //       peer_channels[remotekey_string] = { subsocket }
  //       task_channels[task_id] = { path, subsocket }
  //     })
      
  //     // ----------------------------------------------------------------------
 
  //     socket.on('close', () => {
  //       console.log('-------CLOSE ----------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       topics[string_topic].peers[peerkey] = undefined 
  //     })
  //     socket.on('end', () => { 
  //       console.log('-------_END ----------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       console.log('---------------------------')
  //       topics[string_topic].peers[peerkey] = undefined 
  //     })
  //     // socket.on('error', () => {
  //     //   socket.destroy()
  //     //   topics[string_topic].peers[peerkey] = undefined
  //     // })
  //     function onStream(stream, id) {
  //       // onStream will be called with (sub_socket, id) whenever
  //       // a new remote sub-socket is created with an id that hasn't
  //       // already been created locally with plex.createStream()
  //       stream.on('data', function(c) {
  //         console.log('data', id, c.toString())
  //       })
  //     }
  //   })


  // function handle_peer ({ socket, info, string_topic }) {
  //   const { publicKey } = info
  //   const remotekey = publicKey.toString('hex')
    
  //   const task_ids = Object.keys(store.tasks)
  //   for (var i = topics.lengh; i--;) {
  //     const task_id = task_ids[i]
  //     const { topic, callback } = store.tasks[task_id]
  //     const task_topic = topic.toString('hex')
  //     if (string_topic === task_topic) {
  //       const onconnection = callback(remotekey)
  //       if (onconnection) onconnection(plexstream)
  //     }
  //   }


  //   // new connection => check if peer exists 
  //   if (!store.peers[remotekey]) {
  //     store.peers[remotekey] = {
  //       socket, 
  //       info, 
  //       task_channels: {}
  //     }
  //   }

  // }

  /*
  
---------------------------------

// TODO: persist info to users serviceDB to restore connection states on process reboot
const store = {
  topics: {
    string_topic1: {
      discovery,
      task_channels: {
        task_id1: subsocket,
        task_id2: subsocket,
        task_id3: subsocket,
      },
    },
  },
  tasks: {
    task_id1: {
      path, // for debugging purposes
      topic,
      callback,
      peer_channels: { // keeping track to close them later
        remotekey1: subsocket,
        remotekey2: subsocket
      },
    },
  },
  peers: {
    remotekey1: {
      socket, // keeping track to close them later
      plex, // to create subsockets + keeping track to close them later
      info, // to listen to joining/leaving topics
      task_channels: {
        task_id1: subsocket,
        task_id2: subsocket,
        task_id3: subsocket,
      }
    },
  }
}

const topics = {
  string_topic1: {
    discovery,
    tasks: {
      task_id1: {
        path, // for debugging purposes
        onconnection,
        peer_channels: { // keeping track to close them later
          remotekey1: subsocket,
          remotekey2: subsocket
        }
      }
      task_id2: {},
      task_id3: {},
    }, 
    peers: {
      remotekey1: {
        socket, // keeping track to close them later
        plex, // to create subsockets + keeping track to close them later
        info, // to listen to joining/leaving topics
        task_channels: {
          task_id1: subsocket,
          task_id2: subsocket,
          task_id3: subsocket,
        }
      },
      remotekey2: {},
      remotekey3: {},
    }
  },
  string_topic2: { },
  string_topic3: { },
}
*/