const hyperswarm = require('hyperswarm')
const HypercoreProtocol = require('hypercore-protocol')
const hypercore = require('hypercore')

module.exports = datdot_swarm

async function datdot_swarm ({ bootstrap, account, log }) {
  var tid
  const { noisePublicKey, noisePrivateKey } = account
  // const swarm = new hyperswarm({ bootstrap, keyPair: { publicKey: noisePublicKey, secretKey: noisePrivateKey } })
  const swarm = new hyperswarm({ keyPair: { publicKey: noisePublicKey, secretKey: noisePrivateKey } })

  swarm.on('connection', async (socket, info) => {
    const protocolStream = new HypercoreProtocol(socket.isInitiator)
    socket.pipe(protocolStream).pipe(socket)
    log({ type: 'swarm', data: { text: `New connection`, socket: socket.isInitiator  } })
    clearTimeout(tid) // clear retry timeout
    const keys = Object.keys(account.cache)
    console.log({ text: 'keys in cache', keys})
    for (var i = 0, len = keys.length; i < len; i++) {
      const stringkey = keys[i]
      const task_ids = Object.keys(account.cache[stringkey].tasks)
      task_ids.forEach(id => account.cache[stringkey].tasks[id].onconnection(socket, protocolStream))
    }
    socket.on('error', (err) => { log({ type: 'swarm', data: { text: `Socket on error`, err } })})
    socket.on('end', () => { log({ type: 'swarm', data: { text: `Socket on end` } })})
    socket.on('close', () => { log({ type: 'swarm', data: { text: `Socket on close` } })})
    protocolStream.on('end', () => { log({ type: 'swarm', data: { text: `protocolStream on end` } })})
    protocolStream.on('close', () => { log({ type: 'swarm', data: { text: `protocolStream on close` } })})
  
  })

  const swarmAPI = { swarm, join_topic }
  return swarmAPI
  
  async function join_topic ({ swarmAPI, feed, role, mode, account, log }) {
    log({ type: role, data: { text: `Joining topic`, role, feedkey: feed.key.toString('hex'), topic: feed.discoveryKey.toString('hex') } })
    const { key: feedkey, discoveryKey: topic } = feed
    const stringkey = feedkey.toString('hex')
    const discovery = swarm.join(topic, mode)
    // await swarm.flush() // Make sure we have all the connections
    var counter = 10
    
    retry(discovery, mode, log)
  
    return discovery
  
    async function retry (discovery, mode, log) {
      if (!discovery) return
      tid = setTimeout(() => {
          log({ type: 'feed', data: { text: 'retrying connection', role }})
          if (counter--) retry(discovery, mode, log)
      }, 1000)
      await discovery.refresh(mode)
    }
  }
  
}



