const crypto = require("hypercore-crypto")
const tree = require('flat-tree')
const sodium = require('sodium-universal')
const derive_seed = require('derive-key')
const { Keyring } = require('@polkadot/keyring')
const keyring = new Keyring({ type: 'sr25519' })
const { seedKeygen } = require('noise-peer')
const proof_codec = require('../datdot-codec/proof')
const uint64be = require('uint64be')
const b4a = require('b4a')
const c = require('compact-encoding')
const Core = require('hypercore/lib/core.js')
const RAM = require('random-access-memory')



module.exports = {
  random_bytes,
  create_signing_keypair,
  create_chain_keypair,
  create_noise_keypair,
  derive_seed,
  verify_signature,
  verify_proof,
  verify_block,
  merkle_verify,
  get_discoverykey,
  get_hash
}

function random_bytes (size) {
  // make sure this is high-entropy master key, eg. from a CSPRNG
  return crypto.randomBytes(size)
}

function create_signing_keypair ({ namespace, seed, name }) {
  const noiseSeed = derive_seed(namespace, seed, name)
  const signingPublicKey = b4a.alloc(32)
  const signingSecretKey = b4a.alloc(64)
  if (noiseSeed) sodium.crypto_sign_seed_keypair(signingPublicKey, signingSecretKey, noiseSeed)
  else sodium.crypto_sign_keypair(signingPublicKey, signingSecretKey)
  return { signingPublicKey, signingSecretKey }
}

function create_chain_keypair ({ namespace, seed, name }) {
  const accountSecret = derive_seed(namespace, seed, name)
  const accountUri = `0x${accountSecret.toString('hex')}`
  return keyring.addFromUri(accountUri)
}

function create_noise_keypair ({ namespace, seed, name }) {
  const noiseSeed = derive_seed(namespace, seed, name)
  const publicKey = b4a.alloc(32)
  const secretKey = b4a.alloc(64)
  if (noiseSeed) sodium.crypto_sign_seed_keypair(publicKey, secretKey, noiseSeed)
  else sodium.crypto_sign_keypair(publicKey, secretKey)
  return { publicKey, secretKey }
}

function verify_signature (signature, message, signingPublicKey) {
  console.log({ text: 'verifying signature', signature, message, signingPublicKey })
  return sodium.crypto_sign_verify_detached(signature, message, signingPublicKey)
}

async function verify_proof (p, feedkey) {
  return new Promise(async (resolve, reject) => {
    const core = await createCore({ keyPair: { publicKey: feedkey} })
    console.log('verifying proof in datdot-crypto', p)
    const verified = await core.verify(p)
    if (!verified) return reject()
    resolve(p)
  })
}

async function verify_block (p, data) {  
  return new Promise(async (resolve, reject) => {
    const block_val = p.block.value
    data = b4a.from(data)
    console.log({block_val, data})
    const v = b4a.compare(block_val, data) // returns 0
    v ? reject() : resolve(true)
  })
}

function hash (data) {
  const LEAF_TYPE = b4a.from([0])
  const out = b4a.allocUnsafe(32)

  sodium.crypto_generichash_batch(out, [
    LEAF_TYPE,
    c.encode(c.uint64, data.byteLength),
    data
  ])

  return out
}

async function createCore (opts) {
  const storage = new Map()

  const createFile = (name) => {
    if (storage.has(name)) return storage.get(name)
    const s = new RAM()
    storage.set(name, s)
    return s
  }

  return await Core.open(createFile, opts)
}

async function merkle_verify ({feedKey, hash_index, version, signature, nodes}) {
  var next = nodes.find(node => node.index === hash_index)
  const roots = tree.fullRoots(version*2)
  roots.push(version*2)
  while (!roots.includes(next.index)) {
    const sibling_index = tree.sibling(next.index)
    const parent_index = tree.parent(next.index)
    next = hash_pair(nodes, next, sibling_index, parent_index)
  }
  const root_node = nodes.find(node => node.index === next.index)
  if (b4a.compare(next.hash, root_node.hash)) return 'all hashes up to root not verified'
  if (!await verify(nodes, roots, signature, feedKey, version)) return'checksum not verified'
  
  function hash_pair (nodes, next, sibling_index, parent_index) {
    const sibling = nodes.find(node => node.index === sibling_index)
    const parent_hash = crypto.parent(next, sibling)
    const parent = {
      index: parent_index,
      hash: parent_hash,
      size: next.size + sibling.size
    }
    return parent
  }

  async function verify (nodes, roots, signature, feedKey, version) {
    for (var i = 0, len = roots.length; i < len; i++) {
      nodes.find(node => { 
        if (node.index === roots[i]) {
          roots[i] = node
        }
      })
    }
    console.log('get checksum', roots)
    const checksum = await get_checksum(roots) // hash roots together
    console.log('got checksum', checksum)
    const foo = crypto.verify(checksum, signature, feedKey)
    console.log('after verify', foo)
    return 
  }  
}

  function get_discoverykey (feedkey) {
    const HYPERCORE = b4a.from('hypercore')
    const digest = b4a.allocUnsafe(32)
    sodium.crypto_generichash(digest, HYPERCORE, feedkey)
    return digest
  }

  async function get_checksum (roots) {
    const buffers = new Array(3 * roots.length + 1)
    let j = 0
  
    buffers[j++] = b4a.from([2])
  
    for (let i = 0; i < roots.length; i++) {
      const r = roots[i]
      buffers[j++] = r.hash
      buffers[j++] = c.encode(c.uint64, r.index)
      buffers[j++] = c.encode(c.uint64, r.size)
    }
  
    const out = b4a.allocUnsafe(32)
    sodium.crypto_generichash_batch(out, buffers)
    return out
  }

  function get_hash (buf) {
    const topicHash = b4a.allocUnsafe(32)
    sodium.crypto_generichash(topicHash, buf)
    return topicHash
  }

// @NOTE:
// check comments in this commit https://github.com/playproject-io/datdot-service/blob/wip/src/vault.js

// -------------------------------------------------
// async function compare_root_signatures (signatures, sig_object, key) {
//   const sig = sig_object.signature // TODO: maybe we should also compare indexes in const sig_object = { index: 3, signature: 'wefwfwr'}
//   return new Promise((resolve, reject) => {
//     signatures.push({ sig, key, resolve, reject })
//     if (signatures.length === 3) {
//       const [ a, b, c ] = signatures
//       if (a.sig === b.sig && b.sig === c.sig) resolve_all(signatures, a.sig)
//       else if (a.sig === b.sig && b.sig !== c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: c.key }) // one sig is different, that encoder fails (can 2 encoders squeeze out the other? should we rather fail all encoders?)
//       else if (a.sig !== b.sig && b.sig === c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: a.key })
//       else if (a.sig !== b.sig && a.sig === c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: b.key })
//       else if (a.sig !== b.sig && a.sig !== c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: [a.key, b.key, c.key] })
//     }
//   })
// }
// function resolve_all (signatures, res) {
//   signatures.forEach(entry => entry.resolve(res))
// }
// function reject_all (signatures, res) {
//   signatures.forEach(entry => entry.reject(res))
// }
// -------------------------------------------------