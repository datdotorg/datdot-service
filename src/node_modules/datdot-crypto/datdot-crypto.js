const crypto = require("hypercore-crypto")
const tree = require('flat-tree')
const sodium = require('sodium-universal')
const derive_seed = require('derive-key')
const { Keyring } = require('@polkadot/api')
const keyring = new Keyring({ type: 'sr25519' })
const { seedKeygen } = require('noise-peer')
const parse_decompressed = require('_datdot-service-helpers/parse-decompressed')

module.exports = {
  random_bytes,
  create_signing_keypair,
  create_chain_keypair,
  create_noise_keypair,
  derive_seed,
  verify_signature,
  verify_chunk_hash,
  merkle_verify,
}

function random_bytes (size) {
  // make sure this is high-entropy master key, eg. from a CSPRNG
  return crypto.randomBytes(size)
}

function create_signing_keypair ({ namespace, seed, name }) {
  const noiseSeed = derive_seed(namespace, seed, name)
  const signingPublicKey = Buffer.alloc(32)
  const signingSecretKey = Buffer.alloc(64)
  if (noiseSeed) sodium.crypto_sign_seed_keypair(signingPublicKey, signingSecretKey, noiseSeed)
  else sodium.crypto_sign_keypair(signingPublicKey, signingSecretKey)
  return { signingPublicKey, signingSecretKey }
}

function create_chain_keypair ({ namespace, seed, name }) {
  const accountSecret = derive_seed(namespace, seed, name)
  const accountUri = `0x${accountSecret.toString('hex')}`
  return keyring.addFromUri(accountUri)
}

function create_noise_keypair ({ namespace, seed, name }) {
  const noiseSeed = derive_seed(namespace, seed, name)
  return seedKeygen(noiseSeed)
}

function verify_signature (signature, message, signingPublicKey) {
  return sodium.crypto_sign_verify_detached(signature, message, signingPublicKey)
}

async function verify_chunk_hash (index, decompressed, unique_el, nodes) {
  return new Promise(async (resolve, reject) => {
    const decoded = parse_decompressed(decompressed, unique_el)
    const node = nodes.find(node => node.index === index * 2)
    const hash = crypto.data(decoded)
    if (Buffer.compare(node.hash, hash)) reject()
    resolve()
  })
}

function merkle_verify ({feedKey, hash_index, version, signature, nodes}) {
  var next = nodes.find(node => node.index === hash_index)
  const roots = tree.fullRoots(version*2)
  roots.push(version*2)
  while (!roots.includes(next.index)) {
    const sibling_index = tree.sibling(next.index)
    const parent_index = tree.parent(next.index)
    next = hash_pair(nodes, next, sibling_index, parent_index)
  }
  const root_node = nodes.find(node => node.index === next.index)
  if (Buffer.compare(next.hash, root_node.hash)) return 'all hashes up to root not verified'
  if (!verify(nodes, roots, signature, feedKey, version)) return'checksum not verified'
  
  function hash_pair (nodes, next, sibling_index, parent_index) {
    const sibling = nodes.find(node => node.index === sibling_index)
    const parent_hash = crypto.parent(next, sibling)
    const parent = {
      index: parent_index,
      hash: parent_hash,
      size: next.size + sibling.size
    }
    return parent
  }

  function verify (nodes, roots, signature, feedKey, version) {
    for (var i = 0, len = roots.length; i < len; i++) {
      nodes.find(node => { 
        if (node.index === roots[i]) {
          roots[i] = node
        }
      })
    }
    const checksum = crypto.signable(roots, version+1)
    return crypto.verify(checksum, signature, feedKey)
  }
}

// @NOTE:
// check comments in this commit https://github.com/playproject-io/datdot-service/blob/wip/src/vault.js

// -------------------------------------------------
// async function compare_root_signatures (signatures, sig_object, key) {
//   const sig = sig_object.signature // TODO maybe we should also compare indexes in const sig_object = { index: 3, signature: 'wefwfwr'}
//   return new Promise((resolve, reject) => {
//     signatures.push({ sig, key, resolve, reject })
//     if (signatures.length === 3) {
//       const [ a, b, c ] = signatures
//       if (a.sig === b.sig && b.sig === c.sig) resolve_all(signatures, a.sig)
//       else if (a.sig === b.sig && b.sig !== c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: c.key }) // one sig is different, that encoder fails (can 2 encoders squeeze out the other? should we rather fail all encoders?)
//       else if (a.sig !== b.sig && b.sig === c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: a.key })
//       else if (a.sig !== b.sig && a.sig === c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: b.key })
//       else if (a.sig !== b.sig && a.sig !== c.sig) reject_all(signatures, { type: 'compare_root_signature_fail', data: [a.key, b.key, c.key] })
//     }
//   })
// }
// function resolve_all (signatures, res) {
//   signatures.forEach(entry => entry.resolve(res))
// }
// function reject_all (signatures, res) {
//   signatures.forEach(entry => entry.reject(res))
// }
// -------------------------------------------------
