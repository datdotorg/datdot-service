const datdot_logkeeper = require('datdot-logkeeper')
const datdot_chain = require('datdot-chain')
const datdot_vault = require('datdot-vault')
const datdot_service = require('../../../')

/******************************************************************************
  BEHAVIORS
******************************************************************************/
const register_chain_account = require('./behavior/register-chain-account.js')
const author_hypercore = require('./behavior/author-hypercore.js')
const subscribe_to_plan = require('./behavior/subscribe-to-plan.js')
const offer_service = require('./behavior/offer-service.js')
/******************************************************************************
  SIMULATE USER
******************************************************************************/
const [scenario, config, logport] = process.argv.slice(2)

user(JSON.parse(scenario), JSON.parse(config), logport)

async function user ({name, behavior}, config, logport) {
  behavior = [...new Set(behavior)]
  const log = await datdot_logkeeper(name, logport)
  log({ type: 'init', data:  { name, behavior } })
  captureErrors(log)
  const profile = { name, log, config }

  const serviceAPI = await datdot_service(profile)
  const chainAPI = await datdot_chain(profile)
  const vaultAPI = await datdot_vault(profile)

  for (var i = 0, len = behavior.length; i < len; i++) {
    const behavior_name = behavior[i]
    const profile = { name, log: log.sub(behavior_name), config }
    if (behavior_name === 'register_chain_account') {
      await register_chain_account(profile, { chainAPI, vaultAPI })
    } else if (behavior_name === 'author_hypercore') {
      await author_hypercore(profile)
    } else if (behavior_name === 'subscribe_to_plan') {
      await subscribe_to_plan(profile, { chainAPI, vaultAPI })
    } else if (behavior_name === 'offer_service') {
      await offer_service(profile, { serviceAPI, chainAPI, vaultAPI })
    }
  }
}

function captureErrors (log) {

  // @TODO: set up websockets to auto-reconnect with backoff and detect broken connection
  log({ type: '@todo', data: 'set up websockets to auto-reconnect with backoff and detect broken connection' })

  const keepalive = () => {
    log({ type: 'keep-alive', data: '. . .' })
  }
  keepalive()
  setInterval(keepalive, 5000)

  process.on('unhandledRejection', error => {
    const stack = (error||{}).stack
    const error_msg = { type: 'user', data: [`unhandledRejection ${stack} ${error}`] }
    log(error_msg)
  })
  process.on('uncaughtException', (error, origin) => {
    const stack = error.stack
    const error_msg = { type: 'user', data: [`uncaughtException ${stack} ${error} ${origin}`] }
    log(error_msg)
  })
  process.on('warning', error => {
    const stack = error.stack
    const error_msg = { type: 'user', data: [`warning ${stack} ${error}`] }
    log(error_msg)
  })
  process.setMaxListeners(0)
}
