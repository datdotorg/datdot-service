const datdot_logkeeper = require('datdot-logkeeper')
const datdot_chain = require('datdot-chain-sdk')
const datdot_vault = require('datdot-vault')
const datdot_service = require('../../../')
const datdot_swarm = require('_datdot-service-helpers/datdot-swarm')

/******************************************************************************
  BEHAVIORS
******************************************************************************/
const register_chain_account = require('./behavior/register-chain-account.js')
const author_hypercore = require('./behavior/author-hypercore.js')
const subscribe_to_plan = require('./behavior/hosting-plan.js')
const offer_service = require('./behavior/offer-service.js')
/******************************************************************************
  SIMULATE USER
******************************************************************************/
const [scenario, config, logport] = process.argv.slice(2)

const { bootstrap } = JSON.parse(config)

user(JSON.parse(scenario), JSON.parse(config), logport)

async function user ({name, behavior}, config, logport) {
  behavior = [...new Set(behavior)]
  const log = await datdot_logkeeper(name, logport)
  log({ type: 'init', data:  { name, behavior } })
  captureErrors(log)
  const profile = { name, log, config }
  log({ type: 'user', data:  { text: 'this is', profile: JSON.stringify(profile) } })

  try {
    const serviceAPI = await datdot_service(profile)
    log({ type: 'user', data:  { text: 'serviceAPI' } })
    const chainAPI = await datdot_chain(profile)
    log({ type: 'user', data:  { text: 'chainAPI' } })
    const vaultAPI = await datdot_vault(profile)
    log({ type: 'user', data:  { text: 'vaultAPI' } })
    // const swarmAPI = await datdot_swarm()

    const account = vaultAPI 
    const swarmAPI = await datdot_swarm({ bootstrap, account, log })
    log({ type: 'user', data:  { text: 'swarmAPI' } })
    
    for (var i = 0, len = behavior.length; i < len; i++) {
      const behavior_name = behavior[i]
      const profile = { name, log: log.sub(behavior_name), config }
      log({ type: 'user', data:  { text: 'behavior', name, behavior_name } })
      if (behavior_name === 'register_chain_account') {
        await register_chain_account(profile, { swarmAPI, chainAPI, vaultAPI })
      } else if (behavior_name === 'author_hypercore') {
        await author_hypercore(profile, { swarmAPI, chainAPI, vaultAPI })
      } else if (behavior_name === 'subscribe_to_plan') {
        await subscribe_to_plan(profile, { swarmAPI, chainAPI, vaultAPI })
      } else if (behavior_name === 'offer_service') {
        await offer_service(profile, { swarmAPI, serviceAPI, chainAPI, vaultAPI })
      }
    }
  } catch (error) {
    log({ type: 'fail', data: { message: error.message, stack: error.stack } })
  }
}

function captureErrors (log) {

  // @TODO: set up websockets to auto-reconnect with backoff and detect broken connection
  log({ type: '@todo', data: 'set up websockets to auto-reconnect with backoff and detect broken connection' })

  const keepalive = () => {
    log({ type: 'keep-alive', data: '. . .' })
  }
  keepalive()
  setInterval(keepalive, 5000)

  process.on('unhandledRejection', error => {
    const stack = (error||{}).stack
    const error_msg = { type: 'user', data: [`unhandledRejection ${stack} ${error}`] }
    log(error_msg)
  })
  process.on('uncaughtException', (error, origin) => {
    const stack = error.stack
    const error_msg = { type: 'user', data: [`uncaughtException ${stack} ${error} ${origin}`] }
    log(error_msg)
  })
  process.on('warning', error => {
    const stack = error.stack
    const error_msg = { type: 'user', data: [`warning ${stack} ${error}`] }
    log(error_msg)
  })
  process.setMaxListeners(0)
}
