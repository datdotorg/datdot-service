const datdot_vault = require('datdot-vault')

const datdot_logkeeper = require('datdot-vault/logkeeper')


const [scenario, config, logport] = process.argv.slice(2)

const { bootstrap } = JSON.parse(config) //TODO: where to use bootstrap?

user_vault(JSON.parse(scenario), JSON.parse(config), logport)


async function user_vault ({name, behavior}, config, logport) {
  behavior = [...new Set(behavior)]

  const log = await datdot_logkeeper(name, logport)

  log({ type: 'init', data:  { name, behavior } })

  captureErrors(log)
  const profile = { name, log, config }
  log({ type: 'user', data:  { text: 'this is', profile: JSON.stringify(profile) } })
  
  try {

    const vaultAPI = await datdot_vault(profile)
    log({ type: 'user', data:  { text: 'vaultAPI' } })
  } catch (error) {

  }

}

// ------------------------------------------------------------------------
// BRAINSTORMING CODE:
// ------------------------------------------------------------------------
// ----
const vaultAPI = { // Vault
  async use (name, pubkey) {
    const source = await getsource(name, pubkey) // hyper, npm, github
    const id = [name, pubkey, rootkey]
    // var kp = await _rootfeedbee.get(id)
    // if (!kp) {
      const keypair = crypto.deriveKeypair(...id)
      // await _rootfeedbee.put(id, keypair)
      // kp = keypair
    // }
    // isolate-js:
    const AsyncFunction = (async () => {}).constructor
    var afunc = AsyncFunction('keypair', '{ use }', `
      ${source}
    `)
    const api = {
      use: name => { }
    }
    afunc(keypair, api)
  }
}
// ----
button.onclick = event => {
  web3Provider.updateUserPolicies(form)
  web3Provider.sendTransaction('....', inputElement.value)
}
// ------------------------------------------------------------------------
// NO GO:
// ------------------------------------------------------------------------
// ----
const keypair = await vault.getKeypair('I am APP_5', 'X')
// => any app (including malicious) can pretend to be APP_5
// ----
const datdot_chain = require('datdot-chain')
const keypair = vaultAPI.keypair('datdot-chain')
// => any (including malicious) app can request the 'datdot-chain' keypair and use it
const chainAPI = datdot_chain2(keypair)
// ----

// ------------------------------------------------------------------------
// BRAINSTORM:
// ------------------------------------------------------------------------

// What is our trust model?
// => PROBLEMS and/or TRUST MODEL:

// 1. app developer can use provided app/module keypair
// 2. app developer can define derived keypair names for their app
// 3. app developer gives derived keys to sub apps or modules

// use case 1:
// => have a sub keypair to be not connected to parent keypair
// => have sub keypair connected to parent keypair

// if sub apps are chosen by APP DEVELOPER, they have free hand
// => by providing parent keys or (auto) signing a message request of a sub app
// ==> the app developer specifies immutable versions and ensures sub apps are not malicious
// ==> if they are, it goes on the APP DEVELOPERS reputation in the eyes of the USER

// if sub apps are chosen by USER (e.g. install module/app)
// => by providing parent keys or (auto) signing a message request of a sub app
// ==> the user specifies 



// EVERY APP from USER perspective has a NEW KEY PAIR
// -> including sub and subsub module keys of apps
// USER can list all keys and sub key pairs
// -> potential problem is 2 sibling apps/modules can try to request same keypair
// --> in case of app developer, its their responsibility
// --> if they fuck it up, it can corrupt user data for that APP


// --> it is possible for a user to investigate history, roll back and fix it


// --> user can barely understand if a named keypair request of an APP
// ---> from 2 different sub modules of that app, is legitimate or not

// USER 
// -> potential problem is 2 sibling apps/modules can try to request same keypair
// --> in case of USER, its problematic
// --> APP can request named keypair which belongs to another app
// --> therefore every APP should get a key based on its domain/author/feed pubkey
// --> but then how can an app proof to the outside world it acts on behalf of the user?

// 1:
// APP DEV creates an app (=AGENT GROUP)
// USER trusts app dev's AGENT GROUP
// USER can trust many AGENT GROUPs
// -> making and delegating a keypair just means to delegate full power until revoked


// 2:
// USER needs to be able to have control over their data
// USER needs control over its AGENT GROUPs
// an AGENT GROUP needs to be able to have control over its data
// an AGENT GROUP needs control over its sub agents

// 3:
// an AGENT GROUP need to proof to outside world it acts on behalf of USER
// a SUB AGENT needs to proof to outside wolrd it acts on behalf of AG or USER
// AGENT GROUP or SUB AGENTS need to write feed data confirmed by USER

// 4:
// USER needs to be able to intervene/correct when AGENTS misbehave
// REMOTE USER needs to be sure what they receive is confirmed by USER
// APP DEV needs to be able to intervene/correct when SUB AGENTS misbehave


// ...
//    ...
// ...
//    ...
// ...


// 4. what if sub app needs to sign something with parent key?

// => This opens the door for any "sub app" to request this
// => a malicious app could make a malicious request
// => a user needs to investigate every request made by an app

// so how does a module with an independent keypair associate with a user?

// every component/instance sends/receives messages via its own address (virtual) feed
// real USER IO should maybe only happen on the borders

// EXPAMPLE:
// chain module instance loads
// service instance module loads
// chain emits events -> forwarded to service
// service emits events -> forwarded to chain
// some chain calls get forwarded to chain
// some service calls get forwarded to hyper

// calls to hyper might need to inform remote about chain account
// calls to chain might need to inform chain about hyper account
// ----


// ------------------------------------------------------------------------
// WISHES:
// ------------------------------------------------------------------------
// ----



// ------------------------------------------------------------------------
// CODE:
// ------------------------------------------------------------------------
// ----
// 1. REQUIREMENT: vault needs root keypair
// * smart vault is some sort of user agent (because real user is in front of the screen)
const vault = datdot_vault(rootkey, async request => {
  const allow = await prompt_user(request)
  if (allow) return true // allow
  else false // deny
})
// ----
// 2. REQUIREMENT: apps need app specific keypairs and data storage
// => hyperswarm needs a noisekeypair
// => hyperdrive needs data storage (e.g. files on disk)
// 2a. REQUIREMENT: on first load, KEYS can be generated and saved under names (e.g. app names)
// 2b. REQUIREMENT: on later loads, KEYS can be loaded per app based on the save names (e.g. app names)
// 3. REQUIREMENT: chain needs keypair + maybe sub keypairs
vaultAPI.use('datdot-chain', '<chain-app-feedkey>') // trust app dev
vaultAPI.use('funny-meme-app', '<funnymeme-app-feedkey>') // trust app dev
vaultAPI.use('funny-meme-app', '<chain-app-feedkey>') // trust app dev
// 4. REQUIREMENT: service needs keypair + sub keypairs
// 5. REQUIREMENT: service needs to proof to peers they are a specific chain peer
vaultAPI.use('datdot-service', 'npm-or-github-module-name') // trust app dev + npm/github
vaultAPI.use('datdot-service', datdot_service_module) // user made local definition executes source
// ------------------------------------------------------------------------