const dateToBlockNumber = require('_date-to-blocknumber')
const get_max_index = require('_datdot-service-helpers/get-max-index')
const remove_task_from_cache = require('_datdot-service-helpers/remove-task-from-cache')
const download_range = require('_datdot-service-helpers/download-range')
const get_index = require('_datdot-service-helpers/get-index')
const getChatAPI = require('_chat/client')
const datdot_crypto = require('datdot-crypto')
const proof_codec = require('datdot-codec/proof')
const b4a = require('b4a')
/******************************************************************************
  ROLE: sponsor

    1. make and publish a plan subscription

******************************************************************************/

module.exports = hosting_plan

async function hosting_plan (profile, APIS) {
  const { chainAPI, vaultAPI, store } = APIS
  const account = await vaultAPI
  const log = profile.log
  const chatAPI = await getChatAPI(profile)

  log({ type: '@todo', data: 'given e.g. a feed address, use helper features from serviceAPI' })
  // TODO: given e.g. a feed address, use helper features
  // => serviceAPI should offer feature to retrieve
  // => data required to submit to the chain to start a plan subscription

  log({ type: 'sponsor', data: [`I am a sponsor`] })
  await chainAPI.listenToEvents(handleEvent)
  const myAddress = await vaultAPI.chainKeypair.address
  log({ type: 'sponsor', data: [`My address ${myAddress}`] })
  const signer = await vaultAPI.chainKeypair
  const block = await chainAPI.getBlockNumber()
  const task_id = `sponsor-${block}` // TODO: see if task_id is unique

  // EVENTS

  chatAPI.on(async keys => {
    const { feedkey, topic } = JSON.parse(keys)
    log({ type: 'sponsor', data: { text: `Got the keys`, keys, feedkey, topic } })
    const components = await makeComponents(feedkey, topic)
    const duration = await getFromUntilBlock()
    const data = await makePlan( duration, components, topic)
    log({ type: 'sponsor', data: [`Plan created`] })
    const nonce = await vaultAPI.getNonce()
    log({ type: 'sponsor', data: [`Publishing hosting plan to the chain now`] })
    await chainAPI.publishPlan({ data, signer, nonce })
  })

  async function handleEvent (event) {
    if (event.method === 'FeedPublished') {
      log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
    }
    if (event.method === 'StorageChallengeConfirmed') {
      const [storageChallengeID] = event.data
      const { contract: contractID } = await chainAPI.getStorageChallengeByID(storageChallengeID)
      const { plan: planID } = await chainAPI.getContractByID(contractID)
      const { sponsor: sponsorID } = await chainAPI.getPlanByID(planID)
      const sponsorAddress = await chainAPI.getUserAddress(sponsorID)
      if (sponsorAddress === myAddress) {
        log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
      }
    }
    if (event.method === 'PerformanceChallengeConfirmed') {
      const [performanceChallengeID] = event.data
      const { contract: contractID } = await chainAPI.getPerformanceChallengeByID(performanceChallengeID)
      const { plan: planID } = await chainAPI.getContractByID(contractID)
      const { sponsor: sponsorID } = await chainAPI.getPlanByID(planID)
      const sponsorAddress = await chainAPI.getUserAddress(sponsorID)
      if (sponsorAddress === myAddress) {
        // log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
        log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })

      }
    }
  }

  // HELPERS
 // See example https://pastebin.com/5nAb6XHQ
 // all feeds under one Plan have same hosting settings
//  function sponsorPlan () {
//    const sponsorship = {
//      planID,
//      importance : '', // 1-3? 1-10?
//      budget     : '',
//      traffic    : '',
//      price      : '',
//    }
//    return { type: 'start', data: sponsorship }
//  }
//  function updateSponsorship () {
//    return { type: 'pause', data: id }
//    return { type: 'resume', data: id }
//    return { type: 'cancel', data: id }
//    return { type: 'update', data: { id, update: { importance, budget } } }

//     if ( type === 'update') sponsorships[data.id] = Object.assign(sponsorships[data.id], data.update)
//  }

  async function makePlan (duration, components, topic) {
    const plan = {
      duration,
      swarmkey: topic,
      program  : [
        // { plans: [] }, // duplicate program from referenced plans
        {
          dataset: [-1],
          regions: [-1, -2],
          timetables: [-1],
          performances: [-1],
        },
        // { dataset, regions, performance, times },
        // { dataset, regions, performance, times }
      ],
    }
    const unfiltered = plan.program.map(arr => arr.dataset)
    const datasets = [...new Set(unfiltered)].flat()
    const proofs = await getProofs(components, datasets)
    return {
      plan,
      components,
      proofs
    }
  }
  function makePlanUpdate ({ plan }) {
    // - pause plan (define max, after that resume or drop) - maybe pause only performance challenges
    //   -> hosters can pause seeding and dont get paid for seeding, only storing,  while paused
    // ...
    const { program: { add, del, put } } = plan
    Object.entries(put).map(([i, val]) => Object.assign(program[i], val))
    del.map(i => program.splice(i, 1))
    program.push(...add)

    return {
      id,
      components,
      from,
      until,
      program: {
        add: [{ dataset, regions, performance, timetable }, { plans: [33] }],
        del: [0],
        put: {2: { dataset, regions }},
      }
    }
  }

  async function makeComponents (feedkey, topic) {
    const feed1 = { feedkey, swarmkey: topic, signatures: {} } // TODO: see if signatures should be an array
    const feeds = [feed1]
    const dataset_items = [
      { feed_id: -1, ranges: [[0,3], [5,8], [10,14]] },
    ]
    const performance_items = [{ // OPTIONAL
      availability: '', // percentage_decimal
      bandwidth: { /*'speed', 'guarantee'*/ }, // bitspersecond, percentage_decimal
      latency: { /*'lag', 'guarantee'*/ }, // milliseconds, percentage_decimal
    }]
    const timetable_items = [{ // OPTIONAL
      duration : '', // blocknumbers // { from, until }
      delay    : '', // milliseconds // default: 0
      interval : '', // milliseconds // 
      repeat   : '', // number // default: none
    }]
    const region_items = [{ geohash: 'X3F' }, { geohash: 'A0K' }]  // at least 1 region is mandatory (defaults to global)
    return { feeds, dataset_items, performance_items, timetable_items, region_items }
  }

  async function getFromUntilBlock () {
    const blockNow = await chainAPI.getBlockNumber()
    const until = new Date('Nov 26, 2024 23:55:00')
    const untilBlock = dateToBlockNumber ({ dateNow: new Date(), blockNow, date: until })
    return { from: blockNow, until: untilBlock }
  }

  async function getProofs (components, datasets) {
    const proofs = []
    const all = []
    log({ type: 'length', data: { length: datasets.length } })
    for (var i = 0, len = datasets.length; i < len; i++) {
      all.push(new Promise(async (resolve, reject) => {
        const { signatures, feedkey, sig, feed_ref } = await getKeyAndSignature(datasets[i], components)
        if (sig) return
        const keybuff = b4a.from(feedkey)
        const { feed } = await store.load_feed({
          config: { intercept: false, fresh: false, persist: false },
          swarm_opts: { topic: datdot_crypto.get_discoverykey(keybuff), mode: { server: false, client: true } },
          feedkey: keybuff,
          log
        })
        log({ type: 'sponsor', data: { text: `feedkey`, feedkey: feedkey.toString('hex')} })    
        await feed.ready()
        await feed.get(0) // TODO: find a way to continue only after feed has been synced
        await feed.update()
        const v = feed.length*2 - 1
        log({ type: 'sponsor', data: { text: `Getting signature for `, v } })        
        // another check if this signature is already on chain
        if (signatures[v]) return
        const p = await feed.core.tree.proof({ upgrade: { start: 0, length: feed.length }})
        log({ type: 'sponsor', data: { text: `Got the proof`, p } })
        proofs.push({ feed_ref, p: proof_codec.to_string(p) })

        log({ type: 'sponsor', data: { text: `Hypercore replicated`, proofs } })
        await remove_task_from_cache({ store, topic: feed.discoveryKey, tasks: account.cache['general'].tasks, log })
        resolve()

      }))
    }
    await Promise.all(all).catch(err=> log({ type: 'fail', data: err }))
    return proofs
  }
  
  async function getKeyAndSignature (dataset_ref, components) {
    const { feeds, dataset_items } = components
    const dataset_item = dataset_ref > 0 ? await chainAPI.getItemByID(dataset_ref) : dataset_items[(Math.abs(dataset_ref) - 1)]
    const { feed_id: feed_ref, ranges } = dataset_item
    const feed = feed_ref > 0 ? await chainAPI.getItemByID(feed_ref) : feeds[(Math.abs(feed_ref) - 1)]
    const { feedkey, version } = feed
    // check what is the highest verison
    const keys = Object.keys(feed.signatures)
    const signatures = keys.map(key => Number(key))
    if (signatures.length) {
      const max = get_max_index(ranges)
      var index = signatures.find(v => v >= max)
      return { signatures, feedkey, sig: { index, signature: feed.signatures[index] }, feed_ref }
    } else {
      return { signatures, feedkey, feed_ref }
    }
  }

}
