const providerForm = require('_provider-form')
const dateToBlockNumber = require('_date-to-blocknumber')

async function get_duration (blockNow) {
  const until = new Date('Dec 26, 2021 23:55:00')
  const untilBlock = dateToBlockNumber ({ dateNow: new Date(), blockNow, date: until })
  return { from: blockNow, until: untilBlock }
}
/******************************************************************************
  ROLE: worker

    1. register for work (= publish offered services to chain)
    2. listen to task notifications
    3. execute tasks
    4. report task results to chain if required

******************************************************************************/

module.exports = offer_hosting

async function offer_hosting (profile, APIS) {
  const { name, log } = profile
  const { chainAPI, vaultAPI, serviceAPI } = APIS
  
  const myAddress = await vaultAPI.chainKeypair.address
  const nonce = await vaultAPI.getNonce()
  const signer = await vaultAPI.chainKeypair
  const noiseKey = await vaultAPI.noisePublicKey
  const blockNow = await chainAPI.getBlockNumber()

  const identity = { myAddress, signer, noiseKey }


  // @TODO: do not pass APIS but instead forward calls between APIS
  log({ type: '@todo', data: 'do not pass APIS but instead forward calls between APIS' })
  // --------------------------------------------------------------------------------------
  const task_scheduler = require('task-scheduler')
  const item_store = require('item-store')

  const store = item_store()

  // TODO: define store items:
  store.type(`fresh`, make_fresh_feed)

  const make_general_feed = require('make_general_feed')
  store.type(`general`, make_general_feed)

  store.type(`intercept`, make_intercepted_feed)

  store.type(`swarm`, async function make_swarm (data, api) {
    // ..
  })

  const tasker = task_scheduler(store)
  tasker.register('attest-hosting-setup', async function handler_attest (task, api) {
    // ...
  })
  tasker.register('host-hosting-setup', async function handler_host (task, api) {
    // ...
  })
  tasker.register('encode-hosting-setup', async function handler_encode (task, api) {
    const { store, log, add } = api
    await serviceAPI.encode_hosting_setup(task.data, {
      keyPair: Object.assign({}, keyPair, {
        // keyPair.publicKey
        sign: async (data) => vaultAPI.sign(data) // keyPair.sign(data)
        // keyPair.encrypt(data)
        // keyPair.decrypt(data)
        // ...
      }),
      log,
      store,
    })
    log({ type: 'encoder', data: [`Encoding done`] })
    // await new Promise((resolve, reject) => setTimeout(reject, 1000))
  })

  tasker.register('new-amendment', async function handler_newAmendment ({data}, api) {
    const { log, add } = api
    const event = data
    try {
      const task = await get_newAmendment_data_from_chain(myAddress, event)
      if (!task) return
      await add(task)
    } catch (error) {
      log({ type: 'error', data: [`error: ${error}`] })
    }
  })


  

  // serviceAPI.encode(identity, log)
  await chainAPI.listenToEvents(async function handleEvent (event) {
    if (event.method === 'NewAmendment') {
      const task = { type: 'new-amendment', data: event }
      await tasker(task)
    }
  })


  serviceAPI.host(identity, log)
  serviceAPI.attest(identity, log)

  // --------------------------------------------------------------------------------------
  const duration = await get_duration(blockNow)
  const form = providerForm(duration)
  await chainAPI.registerForWork({ signer, nonce, form })
}

/*****************************************************************************/
// EVENTS
/*****************************************************************************/
async function get_newAmendment_data_from_chain (myAddress, event, log) {
    const [amendmentID] = event.data
    const amendment = await chainAPI.getAmendmentByID(amendmentID)
    const contract = await chainAPI.getContractByID(amendment.contract)
    const { encoders, attestors } = amendment.providers
    // @TODO: it is a general chain listeners, so:
    // => find out if there is ANY role in this amendment that isForMe 
    const encoder_pos = await isForMe(myAddress, encoders, event)
    if (encoder_pos === undefined) return
    log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data}`] })
    const { feedkey: feedKey, signatures } = await chainAPI.getFeedByID(contract.feed)
    const [attestorID] = attestors
    const attestorKey = await chainAPI.getAttestorKey(attestorID)
    const data = { amendmentID, attestorKey, encoderKey, ranges: contract.ranges, encoder_pos, signatures, feedKey }
    return { type: 'encode-hosting-setup', data }
}
async function isForMe (myAddress, encoders, event) {
    for (var i = 0, len = encoders.length; i < len; i++) {
      const id = encoders[i]
      const peerAddress = await chainAPI.getUserAddress(id)
      if (peerAddress === myAddress) return i
    }
  }