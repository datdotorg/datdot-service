const dateToBlockNumber = require('_date-to-blocknumber')
const get_max_index = require('_datdot-service-helpers/get-max-index')
const {done_task_cleanup} = require('_datdot-service-helpers/done-task-cleanup')
const getChatAPI = require('_chat/client')
const proof_codec = require('datdot-codec/proof')
const b4a = require('b4a')
const DEFAULT_TIMEOUT = 10000
/******************************************************************************
  ROLE: sponsor

    1. make and publish a plan subscription

******************************************************************************/

module.exports = sponsor_plan

async function sponsor_plan (vaultAPI, APIS) {
  const { chainAPI } = APIS
  const account = vaultAPI
  const { log, hyper } = vaultAPI
  const chatAPI = await getChatAPI(vaultAPI)

  // TODO: given e.g. a feed address, use helper features
  // => serviceAPI should offer feature to retrieve
  // => data required to submit to the chain to start a plan subscription
  const tid = setTimeout(() => {
    log({ type: 'timeout', data: { texts: 'error: sponsor - timeout' } })
    return
  }, DEFAULT_TIMEOUT)

  log({ type: 'sponsor', data: [`I am a sponsor`] })
  const myAddress = await vaultAPI.chainKeypair.address
  log({ type: 'sponsor', data: [`My address ${myAddress}`] })
  const signer = await vaultAPI.chainKeypair
  chainAPI.listenToEvents(handleEvent)

  var myfeed

  async function handleEvent (event) {
    const method = event.method
    if (event.method === 'FeedPublished') {
      log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
    }
    if (method === 'hostingStarted') {
      // const [amendmentID ] = event.data
      // const { contract: contractID } = await chainAPI.getAmendmentByID(amendmentID)
      // const contract = await chainAPI.getContractByID(contractID)
      // const { plan: planID, feed: feedID } = contract
      // const feedkey = await chainAPI.getFeedKey(feedID)
      // if (log.path === 'joshua') {
      //   console.log({ text:'it is joshua', log_path: log.path, feedkey: feedkey.toString('hex'), myfeed: myfeed.toString('hex') })
      //   return
      // }
      // if (feedkey.toString('hex') !== myfeed.toString('hex')) return
      // log({ type: 'sponsor', data: [`Event received by sponsor: ${event.method} ${event.data.toString()}`] })   
      // setTimeout(async() => {
      //   log({ type: 'sponsor', data: { text: 'sponsor unpublishing plan', planID } })
      //   const nonce = await vaultAPI.getNonce()
      //   await chainAPI.unpublishPlan({ planID, signer, nonce })
      // }, 15000)
    }
    if (event.method === 'StorageChallengeConfirmed') {
      const [storageChallengeID] = event.data
      const { contract: contractID } = await chainAPI.getStorageChallengeByID(storageChallengeID)
      const { plan: planID } = await chainAPI.getContractByID(contractID)
      const { sponsor: sponsorID } = await chainAPI.getPlanByID(planID)
      const sponsorAddress = await chainAPI.getUserAddress(sponsorID)
      if (sponsorAddress === myAddress) {
        log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
      }
    }
    if (event.method === 'PerformanceChallengeConfirmed') {
      const [performanceChallengeID] = event.data
      const { contract: contractID } = await chainAPI.getPerformanceChallengeByID(performanceChallengeID)
      const { plan: planID } = await chainAPI.getContractByID(contractID)
      const { sponsor: sponsorID } = await chainAPI.getPlanByID(planID)
      const sponsorAddress = await chainAPI.getUserAddress(sponsorID)
      if (sponsorAddress === myAddress) {
        // log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })
        log({ type: 'chainEvent', data: [`Event received: ${event.method} ${event.data.toString()}`] })

      }
    }
  }

  // EVENTS

  chatAPI.on(async keys => {
    const { feedkey, topic } = JSON.parse(keys)
    log({ type: 'sponsor', data: { text: `Got the keys`, keys, feedkey, topic } })
    const components = await makeComponents(feedkey, topic)
    const duration = await getFromUntilBlock()
    clearTimeout(tid)
    const data = await makePlan( duration, components, topic)
    // log({ type: 'sponsor', data: [`Plan created`] })
    const nonce = await vaultAPI.getNonce()
    log({ type: 'sponsor', data: [`Publish plan`] })
    await chainAPI.publishPlan({ data, signer, nonce })
  })

  // HELPERS
 // See example https://pastebin.com/5nAb6XHQ
 // all feeds under one Plan have same hosting settings
//  function sponsorPlan () {
//    const sponsorship = {
//      planID,
//      importance : '', // 1-3? 1-10?
//      budget     : '',
//      traffic    : '',
//      price      : '',
//    }
//    return { type: 'start', data: sponsorship }
//  }
//  function updateSponsorship () {
//    return { type: 'pause', data: id }
//    return { type: 'resume', data: id }
//    return { type: 'cancel', data: id }
//    return { type: 'update', data: { id, update: { importance, budget } } }

//     if ( type === 'update') sponsorships[data.id] = Object.assign(sponsorships[data.id], data.update)
//  }

  async function makePlan (duration, components, topic) {
    const plan = {
      duration,
      swarmkey: topic,
      program  : [
        // { plans: [] }, // duplicate program from referenced plans
        {
          dataset: [-1],
          regions: [-1, -2],
          timetables: [-1],
          performances: [-1],
        },
        // { dataset, regions, performance, times },
        // { dataset, regions, performance, times }
      ],
    }
    const unfiltered = plan.program.map(arr => arr.dataset)
    const datasets = [...new Set(unfiltered)].flat()
    const proofs = await getProofs(components, datasets)
    return {
      plan,
      components,
      proofs
    }
  }
  function makePlanUpdate ({ plan }) {
    // - pause plan (define max, after that resume or drop) - maybe pause only performance challenges
    //   -> hosters can pause seeding and dont get paid for seeding, only storing,  while paused
    // ...
    const { program: { add, del, put } } = plan
    Object.entries(put).map(([i, val]) => Object.assign(program[i], val))
    del.map(i => program.splice(i, 1))
    program.push(...add)

    return {
      id,
      components,
      from,
      until,
      program: {
        add: [{ dataset, regions, performance, timetable }, { plans: [33] }],
        del: [0],
        put: {2: { dataset, regions }},
      }
    }
  }

  async function makeComponents (feedkey, topic) {
    const feed1 = { feedkey, swarmkey: topic, signatures: {} } // TODO: see if signatures should be an array
    const feeds = [feed1]
    const dataset_items = [
      // { feed_id: -1, ranges: [[0,3]] },
      { feed_id: -1, ranges: [[0,3], [5,8], [10,14]] },
    ]
    const performance_items = [{ // OPTIONAL
      availability: '', // percentage_decimal
      bandwidth: { /*'speed', 'guarantee'*/ }, // bitspersecond, percentage_decimal
      latency: { /*'lag', 'guarantee'*/ }, // milliseconds, percentage_decimal
    }]
    const timetable_items = [{ // OPTIONAL
      duration : '', // blocknumbers // { from, until }
      delay    : '', // milliseconds // default: 0
      interval : '', // milliseconds // 
      repeat   : '', // number // default: none
    }]
    const region_items = [{ geohash: 'X3F' }, { geohash: 'A0K' }]  // at least 1 region is mandatory (defaults to global)
    return { feeds, dataset_items, performance_items, timetable_items, region_items }
  }

  async function getFromUntilBlock () {
    const blockNow = await chainAPI.getBlockNumber()
    const until = new Date('Nov 26, 2024 23:55:00')
    const untilBlock = dateToBlockNumber ({ dateNow: new Date(), blockNow, date: until })
    return { from: blockNow, until: untilBlock }
  }

  async function getProofs (components, datasets) {
    const proofs = []
    const all = []
    log({ type: 'length', data: { length: datasets.length } })
    for (const dataset of datasets) {
      all.push(new Promise(async (resolve, reject) => {
        const { signatures, feedkey, sig, feed_ref } = await getKeyAndSignature(dataset, components)
        if (sig) return
        const keybuff = b4a.from(feedkey)
        var remotestringkey

        // make feed
        const { feed } = await hyper.new_task({ feedkey: keybuff, log })
        myfeed = keybuff
        log({ type: 'sponsor', data: { text: `feedkey`, feedkey: feed.key.toString('hex'), discovery: feed.discoveryKey} })    
        
        // connect to author
        await hyper.connect({
          swarm_opts: { role: 'sponsor', topic: feed.discoveryKey, mode: { server: false, client: true } },
          onpeer,
          log
        })

        function onpeer ({ peerkey, stringtopic }) {
          log({ type: 'encoder', data: { text: `onpeer callback`, stringtopic, peerkey } })
          remotestringkey = peerkey.toString('hex')
        }
        
        await feed.ready()
        await feed.get(0) // TODO: find a way to continue only after feed has been synced
        await feed.update()
        
        const v = feed.length*2 - 1
        log({ type: 'sponsor', data: { text: `Getting signature for `, v } })        
        // another check if this signature is already on chain
        if (signatures[v]) return
        const p = await feed.core.tree.proof({ upgrade: { start: 0, length: feed.length }})
        log({ type: 'sponsor', data: { text: `Got the proof`, p } })
        proofs.push({ feed_ref, p: proof_codec.to_string(p) })

        log({ type: 'sponsor', data: { text: `Hypercore replicated`, proofs } })
        const pubkey = account.noisePublicKey.toString('hex')
        await done_task_cleanup({ role: 'sponsor', peers: [remotestringkey], topic: feed.discoveryKey, state: account.state[pubkey], log })
        resolve()

      }))
    }
    await Promise.all(all).catch(err=> log({ type: 'fail', data: err }))
    return proofs
  }
  
  async function getKeyAndSignature (dataset_ref, components) {
    const { feeds, dataset_items } = components
    const dataset_item = dataset_ref > 0 ? await chainAPI.getItemByID(dataset_ref) : dataset_items[(Math.abs(dataset_ref) - 1)]
    const { feed_id: feed_ref, ranges } = dataset_item
    const feed = feed_ref > 0 ? await chainAPI.getItemByID(feed_ref) : feeds[(Math.abs(feed_ref) - 1)]
    const { feedkey, version } = feed
    // check what is the highest verison
    const keys = Object.keys(feed.signatures)
    const signatures = keys.map(key => Number(key))
    if (signatures.length) {
      const max = get_max_index(ranges)
      var index = signatures.find(v => v >= max)
      return { signatures, feedkey, sig: { index, signature: feed.signatures[index] }, feed_ref }
    } else {
      return { signatures, feedkey, feed_ref }
    }
  }

}
