const sublog = require('_sublog')
const codec = require('_sublog/codec')
const report = require('_sublog/report')
// const log = sublog(`datdot-explorer`, message => report(codec.decode(message)))
function log () {}

module.exports = asdf


function asdf (addresses) {
  window.log = console['log'].bind('console')
  const name = 'datdot-explorer'
  start()
  function start () {
    window.connections = {}
    window.LOG = []
    function logger (port, message) {
      const msgs = connections[port].msgs
      const { head: [from, into, id], refs: [], type, data, meta: { timestamp, stack } } = message

      if (!from) return console.error('missing sender', message)
      if (!into || into !== '*') return console.error('missing recipient', message)

      LOG.push(message)
    }
    for (var i = 0, len = addresses.length; i < len; i++) connect(addresses[i])
    function connect (url) {
      log('connecting and fetching logs from:', url)
      const ws = new WebSocket(url)
      connections[url] = { ws, url, codec: { encode, decode }, msgs: {} }
      var counter = 0
      function decode (json) { return JSON.parse(json) }
      function encode (type, data, cite) {
        const head = [name, url, counter++]
        const message = { head, cite, type, data }
        return JSON.stringify(message)
      }
      ws.onmessage = event => {
        const message = decode(event.data)
        logger(url, message)
      }
      ws.onopen = function open () {
        const message = encode('all:live')
        ws.send(message)
      }
      ws.onclose = function close () {
        const message = encode('close', 'unexpected closing of log server connection for: ' + url)
        console.error(message)
      }
      ws.onerror = function error (err) {
        const message = encode('error', err)
        console.error(message) // setTimeout(() => , 2000)
      }
    }
  }
  return show
}

function show (LOG = window.LOG) {
  const el = document.createElement('div')
  const parser = document.createElement('div')
  el.innerHTML = `
  <div class="log"></div>
  <div class="status">${showStatus(LOG)}</div>
  <style>
    body { margin: 0; }
    .log { height: 85vh; background-color: #000; color: #ccc; display: flex; flex-direction: column; overflow-y: scroll; }
    .status { width: 100vw; height: 100vh; background-color: #000; }
    .item { padding: 5px 12px; font-family: arial; display:flex; flex-direction: row; }
    .name { font-size: 14px; min-width: 250px; }
    .message { font-size: 14px; word-break: break-word; }
  </style>`
  const [log, status] = el.children
  const nums = []
  const names = {}
  LOG.sort((a, b) => a[2] - b[2]) // sort by timestamp

  window.toggleStack = function onclick (el, i) {
    if (el.children.length === 1) el.removeChild(el.lastChild)
    else {
      const message = LOG[i]
      const { head: [from, into, id], refs: [], type, data, meta: { timestamp: time, stack } } = message
      // var segment = ''
      // const stack = _stack.split('\n').map(x=>x.trim()).slice(2).map((line, idx) => {
      //   if (!idx) {
      //     var [start, rest] = line.split('(')
      //     if (!rest) {
      //       rest = start
      //       start = ''
      //     }
      //     segment = rest.split('/lab/scenarios/logkeeper')[0]
      //     return [start, rest.replace(segment, '')].join('')
      //   } else {
      //     return line.replace(segment, '')
      //   }
      // })
      const pre = document.createElement('pre')
      pre.style='color:lime;'
      pre.innerHTML = JSON.stringify(stack, 0, 2)
      el.append(pre)
    }
  }
  for (var i = 0, len = LOG.length; i < len; i++) {
    const message = LOG[i]
    const { head: [from, into, id], refs: [], type, data, meta: { timestamp, stack } } = message
    const name = from
    const stamp = `${timestamp}`.split('.')[0]
    const color = () => (names[name] || (names[name] = getRandomColor()))
    parser.innerHTML = `<div class="item" style="background-color: ${ i%2 ? '#282828' : '#202020'};">
      <div class="name" style="color: ${color()};">
        <span>${name}</span><span style="font-size: 9px"> (${id},${stamp})</span>
      </div>
      <div class="message">${format(i, message)}</div>
    </div>`
    const [element] = parser.children
    log.append(element)
  }
  log.scrollTop = log.scrollHeight
  return el
  function getRandomColor () {
    var num = Math.random() * 360
    for (var i = 0; i < nums.length; i++) if (Math.abs(nums[i] - num) < 30) num = Math.random() * 360
    nums.push(num)
    return `hsla(${num}, 100%, 70%, 1)`
  }
  function hashCode (str) {
    var hash = 0
    for (var i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash)
    return hash
  }
  function intToRGB (i) {
    var c = (i & 0x00FFFFFF).toString(16).toUpperCase()
    return "00000".substring(0, 6 - c.length) + c
  }
  function format (id, message) {
    if (message && typeof message === 'object') {
      var { type, data } = message
      console.log('[format]', type)
      const color = intToRGB(hashCode(type))
      return `<span onclick="toggleStack(this, ${id})" style="color: #${color}">${type}:${data}</span>`
    }
  }
  function showStatus (LOG) {
    return `<div style="color: gray; padding: 10px 40px;"> STATUS
      <div> event NewAmendment: ${countPresence('Event received: NewAmendment')} (7 roles per contract)</div>
      <div> Hosting OK, Starting Challenge Phase: ${countPresence('Starting Challenge Phase')} (3 per contract)</div>
      <br>
      <div> Storage challenge emitted: ${countPresence('"method":"NewStorageChallenge"')}</div>
      <div> Event received (attestor & hoster) ${countPresence('Event received: NewStorageChallenge')}</div>
      <div> Attestor: starting verifyStorageChallenge ${countPresence('Starting verifyStorageChallenge')}</div>
      <div> Hoster: starting Starting sendStorageChallenge ${countPresence('Starting sendStorageChallenge')}</div>
      <div> Hoster Storage fetching data ${countPresence('Fetching data for index')}</div>
      <div> Hoster -> Attestor: sending proof of storage ${countPresence('Sending proof of storage chunk')}</div>
      <div> Attestor received proof ${countPresence('Storage Proof received')}</div>
      <div> Attestor -> Hoster: storage is verified ${countPresence('Storage verified for chunk')}</div>
      <div> Hoster got all reponses: ${countPresence('responses received from the attestor')}</div>
      <div> event StorageChallengeConfirmed: ${countPresence('Event received: StorageChallengeConfirmed')} (3 per contract)</div>
      <br>
      <div> Performance challenge requests: ${countPresence('"method":"NewPerformanceChallenge"')}</div>
      <div> event PerformanceChallengeConfirmed: ${countPresence('Event received: PerformanceChallengeConfirmed')} (5 per contract)</div>
      <br>
      <div> FAIL_ACK_TIMEOUT: ${countPresence('FAIL_ACK_TIMEOUT')}</div>
      <div> uncaughtException Error: Channel destroyed uncaughtException ${countPresence('uncaughtException Error: Channel destroyed uncaughtException')}</div>
      <div></div>
    </div>`

    function countPresence (phrase) {
      const results = []
      for (var i = 0; i < LOG.length; i ++) {
        const { head: [from, into, id], refs: [], type, data, meta: { timestamp: time, stack } } = LOG[i]
        const name = from
        var DATA
        try {
          if (typeof data !== 'string') DATA = JSON.stringify(data)
        } catch (error) {
          DATA = error.message || '!!! could not stringify DATA !!!'
        }
        if (DATA && DATA.includes(phrase)) results.push(DATA)
        else if (type.includes(phrase)) results.push(DATA)
      }
      return results.length
    }
  }
}
