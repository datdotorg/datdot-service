const sublog = require('_sublog')
const codec = require('_sublog/codec')
const report = require('_sublog/report')
// const log = sublog(`datdot-explorer`, message => report(codec.decode(message)))
const make_message = require('./message_maker')
const terminal = require('datdot-terminal')
const bel = require('bel')
const csjs = require('csjs-inject')

module.exports = asdf

function asdf (addresses) {
  window.log = console['log'].bind('console')
  const name = 'datdot-explorer'
  let recipients = []
  const log_list = terminal({mode: 'compact', expanded: true}, protocol('terminal'))
  const address_list = addresses.map( (url, index) => bel`
  <li class=${css.info}>
    <span class=${css.id}>${index+1}</span>
    <span class=${css.address}>${url}</span>
  </li>`)
  start()
  function start () {
    window.connections = {}
    window.LOG = []
    function logger (port, message) {
      const msgs = connections[port].msgs
      const { head: [from, into, id], refs: [], type, data, meta: { timestamp, stack } } = message

      if (!from) return console.error('missing sender', message)
      if (!into || into !== '*') return console.error('missing recipient', message)

      LOG.push(message)
      recipients['terminal'](message)
    }
    for (var i = 0, len = addresses.length; i < len; i++) connect(addresses[i])
    function connect (url) {
      log('connecting and fetching logs from:', url)
      const ws = new WebSocket(url)
      connections[url] = { ws, url, codec: { encode, decode }, msgs: {} }
      var counter = 0
      function decode (json) { return JSON.parse(json) }
      function encode (type, data, cite) {
        const head = [name, url, counter++]
        const message = { head, cite, type, data }
        return JSON.stringify(message)
      }
      ws.onmessage = event => {
        const message = decode(event.data)
        logger(url, message)
      }
      ws.onopen = function open () {
        const message = encode('all:live')
        ws.send(message)
      }
      ws.onclose = function close () {
        const message = encode('close', 'unexpected closing of log server connection for: ' + url)
        console.error(message)
      }
      ws.onerror = function error (err) {
        const message = encode('error', err)
        console.error(message) // setTimeout(() => , 2000)
      }
    }
  }
  return {logs: log_list, status: show()}

  function protocol (name) {
    return send => {
      recipients[name] = send
      return get
    }
  }
  function get (message) {
    const make = make_message({from: 'datdot-explorer'})
    const msg = make({type: 'ready'})
    recipients['terminal'](msg)
  }
}

function show (LOG = window.LOG) {
  const el = `<div class="status">${showStatus(LOG)}</div>`
  return el

  function showStatus (LOG) {
    return `<section>
      <h3>STATUS</h3>
      <div> event NewAmendment: ${countPresence('Event received: NewAmendment')} (7 roles per contract)</div>
      <div> Hosting OK, Starting Challenge Phase: ${countPresence('Starting Challenge Phase')} (3 per contract)</div>
      <br>
      <div> Storage challenge emitted: ${countPresence('"method":"NewStorageChallenge"')}</div>
      <div> Event received (attestor & hoster) ${countPresence('Event received: NewStorageChallenge')}</div>
      <div> Attestor: starting verifyStorageChallenge ${countPresence('Starting verifyStorageChallenge')}</div>
      <div> Hoster: starting Starting sendStorageChallenge ${countPresence('Starting sendStorageChallenge')}</div>
      <div> Hoster Storage fetching data ${countPresence('Fetching data for index')}</div>
      <div> Hoster -> Attestor: sending proof of storage ${countPresence('Sending proof of storage chunk')}</div>
      <div> Attestor received proof ${countPresence('Storage Proof received')}</div>
      <div> Attestor -> Hoster: storage is verified ${countPresence('Storage verified for chunk')}</div>
      <div> Hoster got all reponses: ${countPresence('responses received from the attestor')}</div>
      <div> event StorageChallengeConfirmed: ${countPresence('Event received: StorageChallengeConfirmed')} (3 per contract)</div>
      <br>
      <div> Performance challenge requests: ${countPresence('"method":"NewPerformanceChallenge"')}</div>
      <div> event PerformanceChallengeConfirmed: ${countPresence('Event received: PerformanceChallengeConfirmed')} (5 per contract)</div>
      <br>
      <div> FAIL_ACK_TIMEOUT: ${countPresence('FAIL_ACK_TIMEOUT')}</div>
      <div> uncaughtException Error: Channel destroyed uncaughtException ${countPresence('uncaughtException Error: Channel destroyed uncaughtException')}</div>
    </section>`

    function countPresence (phrase) {
      const results = []
      for (var i = 0; i < LOG.length; i ++) {
        const { head: [from, into, id], refs: [], type, data, meta: { timestamp: time, stack } } = LOG[i]
        const name = from
        var DATA
        try {
          if (typeof data !== 'string') DATA = JSON.stringify(data)
        } catch (error) {
          DATA = error.message || '!!! could not stringify DATA !!!'
        }
        if (DATA && DATA.includes(phrase)) results.push(DATA)
        else if (type.includes(phrase)) results.push(DATA)
      }
      return results.length
    }
  }
}

const css = csjs`
.list {
  display: grid;
  grid-row-gap: 6px;
  margin-top: 20px;
}
.info {
  display: grid;
  grid-template-columns: minmax(25px, auto) 1fr;
  grid-column-gap: 10px;
  font-size: var(--size14);
  list-style: none;
}
.id {
  display: inline-grid;
  justify-content: center;
  align-items: center;
  font-size: var(--size12);
  color: hsl(var(--color-dark));
  background-color: hsl(var(--color-greyD8));
  border-radius: 8px;
  padding: 2px 4px;
}
.address {
  display: block;
}
`