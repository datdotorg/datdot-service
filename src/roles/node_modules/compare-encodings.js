const proof_codec = require('datdot-codec/proof')

module.exports = compare_encodings

async function compare_encodings ({ messages, key, msg, log }) {
  return new Promise(async (resolve, reject) => {
    // get all three chunks from different encoders, compare and then respond to each
    const message = await msg
    const data = proof_codec.decode(message)
    const { index, encoded_data  } = data
    const size = encoded_data.byteLength // TODO or .length
    if (messages[index]) messages[index].push({ key, size, resolve, reject })
    else messages[index] = [{ key, size, resolve, reject }]
    log({ type: 'attestor', data: [`comparing encodings for index: ${index} => (${messages[index].length}/3)`] })
    if (messages[index].length === 3) {
      log({ type: 'attestor', data: [`Have 3 encodings, comparing them now!`] })
      find_invalid_encoding(messages[index], (err, res) => {
        messages[index].forEach(item => {
          if (err) return item.reject(err)
          log({ type: 'attestor', data: { info: `All 3 encodings for index ${index} verified`, res } })
          if (res) return item.resolve(res)
        })
      })
    }
  })
}
function find_invalid_encoding (messages, cb) {
  const failedEncoders = []
  var smallest = messages[0].size
  for (var i = 0, len = messages.length; i < len; i++) {
    for (var k = i + 1; k < len; k++) {
      const [a, b] = [messages[i].size, messages[k].size]
      if (a !== b) {
        if (a < b) {
          smallest = a
          failedEncoders.push(messages[k].key)
          cb({ type: 'invalid_encoding', key: failedEncoders })
        } else {
          smallest = b
          failedEncoders.push(messages[i].key)
          cb({ type: 'invalid_encoding', key: failedEncoders })
        }
      }
      else cb(null, { type: 'verified' })
    }
  }
}