const proof_codec = require('datdot-codec/proof')

module.exports = compare_encodings

async function compare_encodings ({ messages, key, msg, log }) {
  return new Promise(async (resolve, reject) => {
    // get all three chunks from different encoders, compare and then respond to each
    const message = await msg
    log({ type: 'attester', data: { text: `comparing encodings starts`, message } })
    const data = proof_codec.decode(message)
    const { index, encoded_data  } = data
    const size = encoded_data.byteLength // TODO: or .length
    log({ type: 'attester', data: { text: `encoded data size`, index, byteLength: encoded_data.byteLength, length: encoded_data.length  } })
    if (messages[index]) messages[index].push({ key, size, resolve, reject })
    else messages[index] = [{ key, size, resolve, reject }]
    log({ type: 'attester', data: { text: `comparing encodings for index: ${index} => (${messages[index].length}/3)` } })
    if (messages[index].length === 3) {
      log({ type: 'attester', data: { text: `comparing encodings for index!` } })
      find_invalid_encoding(messages[index], (err, res) => {
        log({ type: 'attester', data: { text: `All 3 encodings for index ${index} verified`, res } })
        messages[index].forEach(item => {
          if (err) return item.reject(err)
          if (res) return item.resolve(res)
        })
      }, log)
    }
  })
}
// difference between the sizes can not be more than 5 bytes or 1% of the value
// size is different if we have a hoster replacement and the unique_el will depend on the amendmentID
// which can be 250 for one encoding and 34000 for replacement encoding
function find_invalid_encoding (messages, cb, log) {
  const failedEncoders = []
  var smallest = messages[0].size
  for (var i = 0, len = messages.length; i < len; i++) {
    for (var k = i + 1; k < len; k++) {
      const [a, b] = [messages[i].size, messages[k].size]
      if (a !== b) {
        log({ type: 'attester', data: { text: `a !== b`, a, b } })
        if ((b - a > 5) || (b - a > (0.01 * b.size))) {
          smallest = a
          failedEncoders.push(messages[k].key)
          cb({ type: 'invalid_encoding', key: failedEncoders })
        } else if ((a - b > 5) || (a - b > (0.01 * a.size))) {
          smallest = b
          failedEncoders.push(messages[i].key)
          cb({ type: 'invalid_encoding', key: failedEncoders })
        }
      }
      else cb(null, { type: 'verified' })
    }
  }
}